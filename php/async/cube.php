<?php

namespace ccxt\async;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\async\abstract\cube as Exchange;
use ccxt\BadSymbol;
use ccxt\InvalidOrder;
use ccxt\OrderNotFound;
use React\Async;
use React\Promise\PromiseInterface;

class cube extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'id' => 'cube',
            'name' => 'cube',
            'countries' => array(),
            'urls' => array(
                'referral' => '',
                'logo' => 'https://www.cube.exchange/assets/cube-logo-180x180.png',
                'api' => array(
                    'rest' => array(
                        'production' => array(
                            'iridium' => 'https://api.cube.exchange/ir/v0',
                            'mendelev' => 'https://api.cube.exchange/md/v0',
                            'osmium' => 'https://api.cube.exchange/os/v0',
                        ),
                        'staging' => array(
                            'iridium' => 'https://staging.cube.exchange/ir/v0',
                            'mendelev' => 'https://staging.cube.exchange/md/v0',
                            'osmium' => 'https://staging.cube.exchange/os/v0',
                        ),
                    ),
                    'ws' => array(
                        'production' => array(
                            'iridium' => 'wss://api.cube.exchange/ir',
                            'mendelev' => 'wss://api.cube.exchange/md',
                            'osmium' => 'wss://api.cube.exchange/os',
                        ),
                        'staging' => array(
                            'iridium' => 'wss://staging.cube.exchange/ir',
                            'mendelev' => 'wss://staging.cube.exchange/md',
                            'osmium' => 'wss://staging.cube.exchange/os',
                        ),
                    ),
                ),
                'www' => 'https://www.cube.exchange/',
                'doc' => 'https://cubexch.gitbook.io/cube-api',
                'fees' => 'https://www.cube.exchange/fees',
            ),
            'version' => 'v0',
            'api' => array(
                'rest' => array(
                    'iridium' => array(
                        'public' => array(
                            'get' => array(
                                '/markets' => 1,
                                '/history/klines' => 1,
                                '/points/loyalty-leaderboard' => 1,
                                '/points/referral-leaderboard' => 1,
                                '/points/blocks-leaderboard' => 1,
                            ),
                        ),
                        'private' => array(
                            'get' => array(
                                '/users/check' => 1,
                                '/users/info' => 1,
                                '/users/subaccounts' => 1,
                                '/users/subaccount/{subaccountId}' => 1,
                                '/users/subaccount/{subaccountId}/positions' => 1,
                                '/users/subaccount/{subaccountId}/transfers' => 1,
                                '/users/subaccount/{subaccountId}/deposits' => 1,
                                '/users/subaccount/{subaccountId}/withdrawals' => 1,
                                '/users/subaccount/{subaccountId}/orders' => 1,
                                '/users/subaccount/{subaccountId}/fills' => 1,
                                '/users/fee-estimate/{market_id}' => 1,
                                '/users/address' => 1,
                                '/users/address/settings' => 1,
                                '/users/loot-boxes' => 1,
                                '/users/invites' => 1,
                                '/users/daily-loyalty' => 1,
                                '/users/user-tier' => 1,
                            ),
                            'post' => array(
                                '/users/withdraw' => 1,
                                '/users/subaccounts' => 1,
                            ),
                            'patch' => array(
                                '/users/subaccount/{subaccountId}' => 1,
                            ),
                        ),
                    ),
                    'mendelev' => array(
                        'public' => array(
                            'get' => array(
                                '/book/{market_id}/snapshot' => 1,
                                '/parsed/book/{market_symbol}/snapshot' => 1,
                                '/book/{market_id}/recent-trades' => 1,
                                '/parsed/book/{market_symbol}/recent-trades' => 1,
                                '/tickers/snapshot' => 1,
                                '/parsed/tickers' => 1,
                            ),
                        ),
                    ),
                    'osmium' => array(
                        'private' => array(
                            'get' => array(
                                '/orders' => 1,
                                '/positions' => 1,
                            ),
                            'delete' => array(
                                '/orders' => 1,
                                '/order' => 1,
                            ),
                            'post' => array(
                                '/order' => 1,
                            ),
                            'patch' => array(
                                '/order' => 1,
                            ),
                        ),
                    ),
                ),
            ),
            'has' => array(
                'CORS' => null,
                'spot' => true,
                'margin' => false,
                'swap' => true,
                'future' => false,
                'option' => false,
                'addMargin' => false,
                'cancelAllOrders' => true,
                'cancelOrder' => true,
                'cancelOrders' => false,
                'closeAllPositions' => false,
                'closePosition' => false,
                'createDepositAddress' => false,
                'createMarketOrder' => false,
                'createOrder' => true,
                'createOrders' => false,
                'createPostOnlyOrder' => false,
                'createReduceOnlyOrder' => false,
                'createStopLimitOrder' => false,
                'createStopMarketOrder' => false,
                'createStopOrder' => false,
                'fetchAccounts' => false,
                'fetchBalance' => true,
                'fetchBorrowInterest' => false,
                'fetchBorrowRateHistory' => false,
                'fetchCanceledOrders' => false,
                'fetchClosedOrders' => 'emulated',
                'fetchCrossBorrowRate' => false,
                'fetchCrossBorrowRates' => false,
                'fetchCurrencies' => true,
                'fetchDeposit' => false,
                'fetchDepositAddress' => false,
                'fetchDepositAddresses' => false,
                'fetchDepositAddressesByNetwork' => false,
                'fetchDeposits' => true,
                'fetchDepositsWithdrawals' => false,
                'fetchFundingHistory' => false,
                'fetchFundingRate' => false,
                'fetchFundingRateHistory' => false,
                'fetchFundingRates' => false,
                'fetchIndexOHLCV' => false,
                'fetchIsolatedBorrowRate' => false,
                'fetchIsolatedBorrowRates' => false,
                'fetchLedger' => false,
                'fetchLedgerEntry' => false,
                'fetchLeverageTiers' => false,
                'fetchMarketLeverageTiers' => false,
                'fetchMarkets' => true,
                'fetchMarkOHLCV' => false,
                'fetchMyTrades' => 'emulated',
                'fetchOHLCV' => true,
                'fetchOpenInterest' => false,
                'fetchOpenInterestHistory' => false,
                'fetchOpenOrders' => true,
                'fetchOrder' => true,
                'fetchOrderBook' => true,
                'fetchOrderBooks' => false,
                'fetchOrders' => true,
                'fetchOrderTrades' => false,
                'fetchPermissions' => false,
                'fetchPosition' => false,
                'fetchPositions' => false,
                'fetchPositionsForSymbol' => false,
                'fetchPositionsRisk' => false,
                'fetchPremiumIndexOHLCV' => false,
                'fetchStatus' => true,
                'fetchTicker' => true,
                'fetchTickers' => true,
                'fetchTrades' => true,
                'fetchTradingFee' => true,
                'fetchTradingLimits' => false,
                'fetchTransactionFee' => false,
                'fetchTransactionFees' => false,
                'fetchTransactions' => false,
                'fetchTransfers' => false,
                'fetchWithdrawAddresses' => false,
                'fetchWithdrawal' => false,
                'fetchWithdrawals' => true,
                'reduceMargin' => false,
                'setLeverage' => false,
                'setMargin' => false,
                'setMarginMode' => false,
                'setPositionMode' => false,
                'signIn' => false,
                'transfer' => false,
                'withdraw' => true,
            ),
            'timeframes' => array(
                '1s' => '1s',
                '1m' => '1m',
                '15m' => '15m',
                '1h' => '1h',
                '4h' => '4h',
                '1d' => '1d',
                '0' => '1s',
                '1' => '1m',
                '2' => '15m',
                '3' => '1h',
                '4' => '4h',
                '5' => '1d',
                'S1' => '1s',
                'M1' => '1m',
                'M15' => '15m',
                'H1' => '1h',
                'H4' => '4h',
                'D1' => '1d',
            ),
            'timeout' => 10000,
            'rateLimit' => 100,
            'userAgent' => false,
            'verbose' => false,
            'markets' => null,
            'symbols' => null,
            'currencies' => null,
            'markets_by_id' => null,
            'currencies_by_id' => null,
            'apiKey' => null,
            'secret' => null,
            'password' => null,
            'uid' => '',
            'options' => array(
                'environment' => 'production',
                'subaccountId' => null,
                'networks' => array(
                    'BTC' => '1',
                    'ERC20' => '2',
                    'SPL' => '3',
                    'DOGE' => '4',
                    'TAO' => '5',
                    'LTC' => '6',
                    'tBTC' => '7',
                    'tETH' => '8',
                ),
                'impliedNetworks' => array(
                    'ETH' => array( 'ERC20' => '2' ),
                    'SOL' => array( 'SPL' => '3' ),
                ),
                'legalMoney' => array(
                    'USD' => true,
                ),
                'mappings' => array(
                    'rawMarketsIdsToMarkets' => array(),
                    'rawCurrenciesIdsToCurrencies' => array(),
                ),
            ),
            'pro' => true,
            'fees' => array(
                'trading' => array(
                    'maker' => $this->parse_number('0.0004'),
                    'taker' => $this->parse_number('0.0008'),
                ),
            ),
            'commonCurrencies' => null,
            'precisionMode' => DECIMAL_PLACES,
            'exceptions' => array(
                'exact' => array(
                    'Must be authorized' => '\\ccxt\\AuthenticationError',
                    'Market not found' => '\\ccxt\\BadRequest',
                    'Insufficient funds' => '\\ccxt\\InsufficientFunds',
                    'Order not found' => '\\ccxt\\BadRequest',
                ),
            ),
        ));
    }

    public function remove_non_base16_chars(string $input): string {
        $base16Chars = '0123456789abcdefABCDEF';
        $result = '';
        for ($i = 0; $i < $this->count_items($input); $i++) {
            if (mb_strpos($base16Chars, $input[$i]) !== -1) {
                $result .= $input[$i];
            }
        }
        return $result;
    }

    public function generate_signature() {
        $timestamp = $this->seconds();
        $timestampBytes = $this->number_to_le($timestamp, 8);
        $secretKeyBytes = $this->base16_to_binary($this->remove_non_base16_chars($this->secret));
        $message = $this->binary_concat($this->encode('cube.xyz'), $timestampBytes);
        $signature = $this->hmac($message, $secretKeyBytes, 'sha256', 'base64');
        return array( $signature, $timestamp );
    }

    public function generate_authentication_headers() {
        list($signature, $timestamp) = $this->generate_signature();
        return array(
            'x-api-key' => $this->apiKey,
            'x-api-signature' => $signature,
            'x-api-timestamp' => (string) $timestamp,
        );
    }

    public function authenticate_request($request) {
        $headers = $this->safe_dict($request, 'headers', array());
        $request['headers'] = $this->extend($headers, $this->generate_authentication_headers());
        return $request;
    }

    public function sign($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        $environment = $this->options['environment'];
        $endpoint = null;
        $apiArray = null;
        if (gettype($api) === 'string') {
            $apiArray = explode(',', $api);
        } else {
            $apiArray = $api;
        }
        for ($i = 0; $i < count($apiArray); $i++) {
            if ($api[$i] === 'iridium') {
                $endpoint = 'iridium';
                break;
            } elseif ($api[$i] === 'mendelev') {
                $endpoint = 'mendelev';
                break;
            } elseif ($api[$i] === 'osmium') {
                $endpoint = 'osmium';
                break;
            }
        }
        $baseUrl = $this->urls['api']['rest'][$environment][$endpoint];
        $url = $baseUrl . $this->implode_params($path, $params);
        $params = $this->omit($params, $this->extract_params($path));
        $methods = array( 'GET', 'HEAD' );
        $found = false;
        for ($i = 0; $i < count($methods); $i++) {
            if ($methods[$i] === $method) {
                if ($this->count_items($params) > 0) {
                    $url .= '?' . $this->urlencode($params);
                }
                $found = true;
                break;
            }
        }
        if (!$found) {
            $body = json_encode ($params);
        }
        $found = false;
        for ($i = 0; $i < count($apiArray); $i++) {
            if ($apiArray[$i] === 'private') {
                $found = true;
                break;
            }
        }
        if ($found) {
            $request = array(
                'headers' => array(
                    'Content-Type' => 'application/json',
                    'Referer' => 'CCXT',
                ),
            );
            $request = $this->authenticate_request($request);
            $headers = $request['headers'];
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function set_sandbox_mode($enable) {
        if ($enable === true) {
            $this->options['environment'] = 'staging';
        } else {
            $this->options['environment'] = 'production';
        }
    }

    public function fetch_market_meta($symbolOrSymbols = null) {
        return Async\async(function () use ($symbolOrSymbols) {
            $symbol = null;
            $marketId = null;
            $market = null;
            $symbols = null;
            $marketIds = null;
            $markets = null;
            Async\await($this->load_markets());
            if ($symbolOrSymbols !== null) {
                if (gettype($symbolOrSymbols) === 'string') {
                    $marketId = str_replace('/', '', strtoupper($symbolOrSymbols));
                    $market = $this->market($marketId);
                    $marketId = $market['id'];
                    $symbolOrSymbols = $this->safe_symbol($marketId, $market);
                    $symbol = $symbolOrSymbols;
                    return array(
                        'symbol' => $symbol,
                        'marketId' => $marketId,
                        'market' => $market,
                        'symbols' => $symbols,
                        'marketIds' => $marketIds,
                        'markets' => $markets,
                    );
                } elseif (gettype($symbolOrSymbols) === 'array' && array_keys($symbolOrSymbols) === array_keys(array_keys($symbolOrSymbols))) {
                    $marketIds = array();
                    $markets = array();
                    for ($i = 0; $i < count($symbolOrSymbols); $i++) {
                        $marketId = str_replace('/', '', strtoupper($symbolOrSymbols[$i]));
                        $market = $this->market($marketId);
                        $marketId = $market['id'];
                        $symbolOrSymbols[$i] = $this->safe_symbol($marketId, $market);
                        $marketIds[] = $marketId;
                        $markets[] = $market;
                    }
                    $symbolOrSymbols = $this->market_symbols($symbolOrSymbols);
                    $symbols = $symbolOrSymbols;
                    return array(
                        'symbol' => $symbol,
                        'marketId' => $marketId,
                        'market' => $market,
                        'symbols' => $symbols,
                        'marketIds' => $marketIds,
                        'markets' => $markets,
                    );
                } else {
                    throw new BadSymbol($this->id . ' $symbolOrSymbols must be a string or an array of strings');
                }
            }
            return array(
                'symbol' => $symbol,
                'marketId' => $marketId,
                'market' => $market,
                'symbols' => $symbols,
                'marketIds' => $marketIds,
                'markets' => $markets,
            );
        }) ();
    }

    public function inject_sub_account_id($request, $params) {
        if ($this->safe_integer($params, 'subaccountId') !== null) {
            $request['subaccountId'] = $this->safe_integer($params, 'subaccountId');
        } elseif ($this->safe_integer($params, 'subAccountId') !== null) {
            $request['subaccountId'] = $this->safe_integer($params, 'subAccountId');
        } elseif ($this->safe_integer($this->options, 'subaccountId') !== null) {
            $request['subaccountId'] = $this->safe_integer($this->options, 'subaccountId');
        } elseif ($this->safe_integer($this->options, 'subAccountId') !== null) {
            $request['subaccountId'] = $this->safe_integer($this->options, 'subAccountId');
        }
    }

    public function fetch_currencies($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * fetches all available currencies on an exchange
             * @see https://cubexch.gitbook.io/cube-api/rest-iridium-api#markets
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} an associative dictionary of currencies
             */
            $response = Async\await($this->restIridiumPublicGetMarkets ($params));
            // {
            //     "result" => {
            //         "assets" => array(
            //             array(
            //                 "assetId" => 1,
            //                 "symbol" => "BTC",
            //                 "decimals" => 8,
            //                 "displayDecimals" => 5,
            //                 "settles" => true,
            //                 "assetType" => "Crypto",
            //                 "sourceId" => 1,
            //                 "metadata" => array(
            //                     "dustAmount" => 3000
            //                 ),
            //                 "status" => 1
            //             ),
            //             ...
            //         ),
            //         ...
            //     }
            // }
            $assets = $this->safe_list($this->safe_dict($response, 'result'), 'assets');
            return $this->parse_currencies($assets);
        }) ();
    }

    public function parse_currencies($assets): ?array {
        $this->options['mappings']['rawCurrenciesIdsToCurrencies'] = array();
        $result = array();
        for ($i = 0; $i < count($assets); $i++) {
            $rawCurrency = $assets[$i];
            $id = strtolower($this->safe_string($rawCurrency, 'symbol'));
            $code = strtoupper($id);
            $name = $this->safe_string($this->safe_dict($rawCurrency, 'metadata'), 'currencyName');
            $networkId = $this->safe_string($rawCurrency, 'sourceId');
            $networks = array();
            $networks[$networkId] = array(
                'id' => $networkId,
            );
            $currency = $this->safe_currency_structure(array(
                'info' => $rawCurrency,
                'id' => $id,
                'numericId' => $this->safe_integer($rawCurrency, 'assetId'),
                'code' => $code,
                'precision' => $this->safe_integer($rawCurrency, 'decimals'),
                'type' => $this->safe_string_lower($rawCurrency, 'assetType'),
                'name' => $name,
                'active' => $this->safe_integer($rawCurrency, 'status') === 1,
                'deposit' => true,
                'withdraw' => true,
                'fee' => null, // TODO Check if it is possible to fill a withdraw fee!!!
                'fees' => array(), // TODO Check if it is possible to fill a withdraw fee!!!
                'networks' => $networks,
                'limits' => array(
                    'amount' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'withdraw' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'deposit' => array(
                        'min' => null,
                        'max' => null,
                    ),
                ),
            ));
            $result[$code] = $currency;
            $this->options['mappings']['rawCurrenciesIdsToCurrencies'][$this->safe_integer($currency, 'numericId')] = $currency;
        }
        return $result;
    }

    public function fetch_markets($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            /**
             * retrieves data on all markets for cube
             * @see https://cubexch.gitbook.io/cube-api/rest-iridium-api#markets
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} an array of objects representing market data
             */
            $response = Async\await($this->restIridiumPublicGetMarkets ($params));
            // {
            //     "result" => {
            //         "assets" => array(
            //             array(
            //                 "assetId" => 1,
            //                 "symbol" => "BTC",
            //                 "decimals" => 8,
            //                 "displayDecimals" => 5,
            //                 "settles" => true,
            //                 "assetType" => "Crypto",
            //                 "sourceId" => 1,
            //                 "metadata" => array(
            //                     "dustAmount" => 3000
            //                 ),
            //                 "status" => 1
            //             ),
            //             ...
            //         ),
            //         "markets" => array(
            //             array(
            //                 "marketId" => 100004,
            //                 "symbol" => "BTCUSDC",
            //                 "baseAssetId" => 1,
            //                 "baseLotSize" => "1000",
            //                 "quoteAssetId" => 7,
            //                 "quoteLotSize" => "1",
            //                 "priceDisplayDecimals" => 2,
            //                 "protectionPriceLevels" => 3000,
            //                 "priceBandBidPct" => 25,
            //                 "priceBandAskPct" => 400,
            //                 "priceTickSize" => "0.1",
            //                 "quantityTickSize" => "0.00001",
            //                 "status" => 1,
            //                 "feeTableId" => 2
            //             ),
            //             ...
            //         ),
            //         "feeTables" => array(
            //             {
            //                 "feeTableId" => 1,
            //                 "feeTiers" => array(
            //                     array(
            //                         "priority" => 0,
            //                         "makerFeeRatio" => 0.0,
            //                         "takerFeeRatio" => 0.0
            //                     }
            //                 )
            //             ),
            //             {
            //                 "feeTableId" => 2,
            //                 "feeTiers" => array(
            //                     {
            //                         "priority" => 0,
            //                         "makerFeeRatio" => 0.0004,
            //                         "takerFeeRatio" => 0.0008
            //                     }
            //                 )
            //             }
            //         )
            //     }
            // }
            $rawMarkets = $this->safe_list($this->safe_dict($response, 'result'), 'markets');
            $rawAssets = $this->safe_list($this->safe_dict($response, 'result'), 'assets');
            $this->currencies = $this->parse_currencies($rawAssets);
            return $this->parse_markets($rawMarkets);
        }) ();
    }

    public function parse_markets($markets): array {
        $this->options['mappings']['rawMarketsIdsToMarkets'] = array();
        $result = array();
        for ($i = 0; $i < count($markets); $i++) {
            if ($this->safe_string($markets[$i], 'status') !== '1') {
                continue;
            }
            $market = $this->parse_market($markets[$i]);
            $result[] = $market;
            $this->options['mappings']['rawMarketsIdsToMarkets'][$this->safe_integer($this->safe_dict($market, 'info'), 'marketId')] = $market;
        }
        return $result;
    }

    public function parse_market($market): array {
        $id = strtoupper($this->safe_string($market, 'symbol'));
        // TODO Expose this object globally for the exchange so the currencies can be retrieved in O(1) time
        $currenciesByNumericId = array();
        for ($i = 0; $i < $this->count_items($this->currencies); $i++) {
            $currenciesKeysArray = is_array($this->currencies) ? array_keys($this->currencies) : array();
            $targetCurrency = $this->safe_value($this->currencies, $currenciesKeysArray[$i]);
            $targetCurrencyNumericId = $this->safe_integer($targetCurrency, 'numericId');
            $currenciesByNumericId[$targetCurrencyNumericId] = $targetCurrency;
        }
        $baseAsset = $currenciesByNumericId[$this->safe_integer($market, 'baseAssetId')];
        $quoteAsset = $currenciesByNumericId[$this->safe_integer($market, 'quoteAssetId')];
        $baseSymbol = $this->safe_string($this->safe_dict($baseAsset, 'info'), 'symbol');
        $quoteSymbol = $this->safe_string($this->safe_dict($quoteAsset, 'info'), 'symbol');
        $marketSymbol = $baseSymbol . $quoteSymbol;
        return $this->safe_market_structure(array(
            'id' => $id,
            'lowercaseId' => strtolower($id),
            'symbol' => $marketSymbol,
            'base' => $this->safe_string($baseAsset, 'code'),
            'quote' => $this->safe_string($quoteAsset, 'code'),
            'settle' => null,
            'baseId' => $this->safe_string($baseAsset, 'id'),
            'quoteId' => $this->safe_string($quoteAsset, 'id'),
            'settleId' => null,
            'type' => 'spot',
            'spot' => true,
            'margin' => false,
            'swap' => false,
            'future' => false,
            'option' => false,
            'active' => $this->safe_integer($market, 'status') === 1,
            'contract' => false,
            'linear' => null,
            'inverse' => null,
            'contractSize' => null,
            'taker' => $this->safe_number($this->safe_dict($this->fees, 'trading'), 'taker'),
            'maker' => $this->safe_number($this->safe_dict($this->fees, 'trading'), 'maker'),
            'expiry' => null,
            'expiryDatetime' => null,
            'strike' => null,
            'optionType' => null,
            'precision' => array(
                'amount' => $this->precision_from_string($this->safe_string($market, 'quantityTickSize')),
                'price' => $this->precision_from_string($this->safe_string($market, 'priceTickSize')),
                'cost' => null,
                'base' => null,
                'quote' => null,
            ),
            'limits' => array(
                'leverage' => array(
                    'min' => null,
                    'max' => null,
                ),
                'amount' => array(
                    'min' => null,
                    'max' => null,
                ),
                'price' => array(
                    'min' => null,
                    'max' => null,
                ),
                'cost' => array(
                    'min' => null,
                    'max' => null,
                ),
            ),
            'created' => null,
            'info' => $market,
        ));
    }

    public function fetch_order_book(string $symbol, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $limit, $params) {
            /**
             * fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             * @see https://cubexch.gitbook.io/cube-api/rest-mendelev-api#book-market_id-snapshot
             * @see https://cubexch.gitbook.io/cube-api/rest-mendelev-api#parsed-book-market_symbol-snapshot
             * @param {string} $symbol unified $symbol of the market to fetch the order book for
             * @param {int} [$limit] the maximum amount of order book entries to return
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} A dictionary of ~@link https://docs.ccxt.com/#/?id=order-book-structure order book structures~ indexed by market symbols
             */
            $meta = Async\await($this->fetch_market_meta($symbol));
            $symbol = $this->safe_string($meta, 'symbol');
            $request = array( 'market_symbol' => $symbol );
            $response = Async\await($this->restMendelevPublicGetParsedBookMarketSymbolSnapshot ($this->extend($request, $params)));
            //
            // {
            //   "result":{
            //       "ticker_id":"BTCUSDC",
            //       "timestamp":1711544655331,
            //       "bids":array(
            //           array(
            //               70635.6,
            //               0.01
            //           )
            //       ),
            //       "asks":array(
            //           array(
            //               70661.8,
            //               0.1421
            //           )
            //       )
            //   }
            // }
            //
            $rawBids = $this->safe_list($this->safe_dict($response, 'result'), 'bids', array());
            $rawAsks = $this->safe_list($this->safe_dict($response, 'result'), 'asks', array());
            $bids = array();
            for ($i = 0; $i < $this->count_items($rawBids); $i++) {
                if (!($this->parse_to_numeric($rawBids[$i][0]) <= 0 || $this->parse_to_numeric($rawBids[$i][1]) <= 0)) {
                    $bids[] = $rawBids[$i];
                }
            }
            $asks = array();
            for ($i = 0; $i < $this->count_items($rawAsks); $i++) {
                if (!($this->parse_to_numeric($rawAsks[$i][0]) <= 0 || $this->parse_to_numeric($rawAsks[$i][1]) <= 0)) {
                    $asks[] = $rawAsks[$i];
                }
            }
            $rawOrderbook = array(
                'bids' => $bids,
                'asks' => $asks,
            );
            $timestamp = $this->safe_integer($this->safe_dict($response, 'result'), 'timestamp'); // Don't use $this->safe_timestamp()
            return $this->parse_order_book($rawOrderbook, $symbol, $timestamp, 'bids', 'asks');
        }) ();
    }

    public function parse_bids_asks($bidasks, int|string $priceKey = 0, int|string $amountKey = 1, int|string $countOrIdKey = 2) {
        return $bidasks;
    }

    public function fetch_ticker(string $symbol, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $params) {
            /**
             * fetches a price $ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
             * @see https://cubexch.gitbook.io/cube-api/rest-mendelev-api#parsed-$tickers
             * @param {string} $symbol unified $symbol of the market to fetch the $ticker for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=$ticker-structure $ticker structure~
             */
            $meta = Async\await($this->fetch_market_meta($symbol));
            $symbol = $this->safe_string($meta, 'symbol');
            $tickers = Async\await($this->fetch_tickers(array( $symbol ), $params));
            $ticker = $this->safe_value($tickers, $symbol, null);
            if ($ticker === null) {
                throw new BadSymbol($this->id . ' fetchTicker() $symbol ' . $symbol . ' not found');
            }
            return $ticker;
        }) ();
    }

    public function parse_ticker($ticker, ?array $market = null): array {
        //
        //       {
        //         ticker_id => "JTOUSDC",
        //         base_currency => "JTO",
        //         quote_currency => "USDC",
        //         $timestamp => 1713217334960,
        //         last_price => 2.6624,
        //         base_volume => 337.12,
        //         quote_volume => 961.614166,
        //         bid => 2.6627,
        //         ask => 2.6715,
        //         high => 3.0515,
        //         low => 2.6272,
        //         open => 2.8051,
        //       }
        //
        $timestamp = $this->safe_integer($ticker, 'timestamp');
        return $this->safe_ticker(array(
            'symbol' => $this->safe_string($market, 'symbol'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'high' => $this->safe_number($ticker, 'high'),
            'low' => $this->safe_number($ticker, 'low'),
            'bid' => $this->safe_number($ticker, 'bid'),
            'bidVolume' => $this->safe_number($ticker, 'base_volume'),
            'ask' => $this->safe_number($ticker, 'ask'),
            'askVolume' => $this->safe_number($ticker, 'quote_volume'),
            'vwap' => null,
            'open' => $this->safe_number($ticker, 'open'),
            'close' => null,
            'last' => $this->safe_number($ticker, 'last_price'),
            'previousClose' => null,
            'change' => null,
            'percentage' => null,
            'average' => null,
            'baseVolume' => $this->safe_number($ticker, 'base_volume'),
            'quoteVolume' => $this->safe_number($ticker, 'quote_volume'),
            'info' => $ticker,
        ), $market);
    }

    public function fetch_tickers(?array $symbols = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $params) {
            /**
             * fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each $market
             * @see https://cubexch.gitbook.io/cube-api/rest-mendelev-api#parsed-tickers
             * @param {string[]|null} $symbols unified $symbols of the markets to fetch the $ticker for, all $market tickers are returned if not assigned
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a dictionary of ~@link https://docs.ccxt.com/#/?id=$ticker-structure $ticker structures~
             */
            $meta = Async\await($this->fetch_market_meta($symbols));
            $symbols = $this->safe_list($meta, 'symbols');
            $response = Async\await($this->restMendelevPublicGetParsedTickers ($params));
            //
            //  {
            //     $result => array(
            //       array(
            //     ticker_id => "JTOUSDC",
            //     base_currency => "JTO",
            //     quote_currency => "USDC",
            //     timestamp => 1713216571697,
            //     last_price => 2.6731,
            //     base_volume => 333.66,
            //     quote_volume => 953.635304,
            //     bid => 2.6653,
            //     ask => 2.6761,
            //     high => 3.0515,
            //     low => 2.6272,
            //     open => 2.8231,
            //      ),
            //    ),
            //  }
            //
            $rawTickers = $this->safe_list($response, 'result', array());
            $result = array();
            for ($i = 0; $i < count($rawTickers); $i++) {
                $rawTicker = $rawTickers[$i];
                $rawTickerId = str_replace('/', '', strtoupper($this->safe_string($rawTicker, 'ticker_id')));
                if ($symbols !== null) {
                    for ($j = 0; $j < count($symbols); $j++) {
                        if (strtoupper($symbols[$j]) === $rawTickerId) {
                            break;
                        }
                    }
                }
                $marketId = null;
                try {
                    $marketId = $this->market_id($rawTickerId);
                } catch (Exception $_exception) {
                    continue;
                }
                $market = $this->market($marketId);
                $symbol = $this->safe_string($market, 'symbol');
                $ticker = $this->parse_ticker($rawTicker, $market);
                $result[$symbol] = $ticker;
            }
            return $this->filter_by_array_tickers($result, 'symbol', $symbols);
        }) ();
    }

    public function fetch_ohlcv(string $symbol, $timeframe = '1m', ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            /**
             * fetches historical candlestick $data containing the open, high, low, and close price, and the volume of a $market
             * @see https://cubexch.gitbook.io/cube-api/rest-mendelev-api#parsed-tickers
             * @param {string} $symbol unified $symbol of the $market to fetch OHLCV $data for
             * @param {string} $timeframe the length of time each candle represents
             * @param {int} [$since] timestamp in ms of the earliest candle to fetch
             * @param {int} [$limit] the maximum amount of candles to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {int[][]} A list of candles ordered, open, high, low, close, volume
             */
            $meta = Async\await($this->fetch_market_meta($symbol));
            $symbol = $this->safe_string($meta, 'symbol');
            $market = $this->safe_dict($meta, 'market');
            $marketNumericId = $this->safe_integer($this->safe_dict($market, 'info'), 'marketId');
            $selectedTimeframe = $this->timeframes[$timeframe];
            $request = array(
                'interval' => $selectedTimeframe,
            );
            if ($marketNumericId !== null) {
                $request['marketId'] = $marketNumericId;
            }
            if ($since !== null) {
                $request['start_time'] = $since; // The unix nanosecond timestamp that this kline covers.
            }
            $response = Async\await($this->restIridiumPublicGetHistoryKlines ($this->extend($request, $params)));
            $data = $this->safe_value($response, 'result', array());
            //
            //  {
            //    "result" => array(
            //      array(
            //        1715280300,
            //        14736,
            //        14736,
            //        14736,
            //        14736,
            //        "7299"
            //      ),
            //      array(
            //        1715279400,
            //        14734,
            //        14768,
            //        14720,
            //        14720,
            //        "14242"
            //      )
            //    )
            //  }
            //
            return $this->parse_ohlcvs($data, $market, (string) $selectedTimeframe, $since, $limit);
        }) ();
    }

    public function parse_ohlcv($ohlcv, ?array $market = null): array {
        // Cube KLine format
        // [
        //     1715278500,  // start_time           |   $ohlcv[0]
        //     14695,       // Kline open price.    |   $ohlcv[1]
        //     14695,       // Kline close price.   |   $ohlcv[2]
        //     14695,       // Kline high price.    |   $ohlcv[3]
        //     14695,       // Kline low price.     |   $ohlcv[4]
        //     "5784"       // volume_hi            |   $ohlcv[5]
        // ]
        //
        // CCXT KLine format
        // [
        //     1504541580000, // UTC timestamp in milliseconds, integer |   $ohlcv[0]
        //     4235.4,        // (O)pen price, float                    |   $ohlcv[1]
        //     4240.6,        // (H)ighest price, float                 |   $ohlcv[3]
        //     4230.0,        // (L)owest price, float                  |   $ohlcv[4]
        //     4230.7,        // (C)losing price, float                 |   $ohlcv[2]
        //     37.72941911    // (V)olume, float                        |   $ohlcv[5]
        // ],
        $normalizer = pow(10, $this->safe_integer($this->safe_dict($market, 'precision'), 'price'));
        return [
            $this->parse_to_numeric($ohlcv[0]),
            $this->parse_to_numeric($ohlcv[1]) / $normalizer,
            $this->parse_to_numeric($ohlcv[3]) / $normalizer,
            $this->parse_to_numeric($ohlcv[4]) / $normalizer,
            $this->parse_to_numeric($ohlcv[2]) / $normalizer,
            $this->parse_to_numeric($ohlcv[5]),
        ];
    }

    public function fetch_balance($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            /**
             * query for balance and get the amount of funds available for trading or funds locked in orders
             * @see https://cubexch.gitbook.io/cube-api/rest-iridium-api#users-positions
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a {@link https://github.com/ccxt/ccxt/wiki/Manual#order-structure balance structure}
             */
            Async\await($this->fetch_market_meta());
            $request = array();
            $this->inject_sub_account_id($request, $params);
            $response = Async\await($this->restIridiumPrivateGetUsersSubaccountSubaccountIdPositions ($this->extend($request, $params)));
            $subaccountId = $this->safe_string($this->options, 'subaccountId');
            $allOrders = Async\await($this->fetch_raw_orders());
            $result = $this->safe_list($this->safe_dict($this->safe_dict($response, 'result'), $subaccountId), 'inner');
            return $this->parse_balance(array( 'result' => $result, 'allOrders' => $allOrders ));
        }) ();
    }

    public function parse_balance($response): array {
        $result = $this->safe_value($response, 'result');
        $allOrders = $this->safe_value($response, 'allOrders');
        $openOrders = array();
        $filledUnsettledOrders = array();
        $allMarketsByNumericId = array();
        for ($i = 0; $i < $this->count_items($this->markets_by_id); $i++) {
            $marketArrayItem = is_array($this->markets_by_id) ? array_values($this->markets_by_id) : array()[$i];
            $market = $marketArrayItem[0];
            $marketInfo = $this->safe_dict($market, 'info');
            $marketNumericId = $this->safe_string($marketInfo, 'marketId');
            $allMarketsByNumericId[$marketNumericId] = $market;
        }
        $free = array();
        $used = array();
        $total = array();
        $currenciesByNumericId = array();
        for ($i = 0; $i < $this->count_items($this->currencies); $i++) {
            $currenciesKeysArray = is_array($this->currencies) ? array_keys($this->currencies) : array();
            $targetCurrency = $this->safe_value($this->currencies, $currenciesKeysArray[$i]);
            $targetCurrencyNumericId = $this->safe_integer($targetCurrency, 'numericId');
            $currenciesByNumericId[$targetCurrencyNumericId] = $targetCurrency;
        }
        for ($i = 0; $i < $this->count_items($result); $i++) {
            $asset = $result[$i];
            $assetAmount = intval($this->safe_string($asset, 'amount'));
            if ($assetAmount > 0) {
                $assetNumericId = $this->parse_to_int($this->safe_string($asset, 'assetId'));
                $currency = $currenciesByNumericId[$assetNumericId];
                $currencyPrecision = $this->safe_integer($currency, 'precision');
                $assetSymbol = $this->safe_string($currency, 'code');
                $total[$assetSymbol] = $assetAmount / pow(10, $currencyPrecision);
                $used[$assetSymbol] = 0; // To prevent the 'parser' from adding 'null' when there are no orders holding an $asset->
                $free[$assetSymbol] = 0; // To prevent the 'parser' from adding 'null' when there are no orders holding an $asset->
            }
        }
        for ($i = 0; $i < $this->count_items($allOrders); $i++) {
            $order = $allOrders[$i];
            $orderStatus = $this->safe_string($order, 'status');
            if ($orderStatus === 'open') {
                $openOrders[] = $order;
            }
            if ($orderStatus === 'filled') {
                $isSettled = $this->safe_string($order, 'settled');
                if (!$isSettled) {
                    $filledUnsettledOrders[] = $order;
                }
            }
        }
        for ($i = 0; $i < $this->count_items($openOrders); $i++) {
            $order = $openOrders[$i];
            $orderMarketId = $this->safe_string($order, 'marketId');
            $orderMarket = $this->safe_dict($allMarketsByNumericId, $orderMarketId);
            $orderSide = $this->safe_string($order, 'side');
            $orderBaseToken = $this->safe_string($orderMarket, 'base');
            $orderQuoteToken = $this->safe_string($orderMarket, 'quote');
            $orderAmount = $this->safe_integer($order, 'qty');
            $orderPrice = $this->safe_integer($order, 'price');
            $targetToken = '';
            $lotSize = 0;
            if ($orderSide === 'Ask') {
                $targetToken = $orderBaseToken;
                $lotSize = $this->safe_integer($this->safe_dict($orderMarket, 'info'), 'baseLotSize');
            } elseif ($orderSide === 'Bid') {
                $targetToken = $orderQuoteToken;
                $lotSize = $this->safe_integer($this->safe_dict($orderMarket, 'info'), 'quoteLotSize');
            }
            $targetCurrency = $this->currency($targetToken);
            $targetCurrencyPrecision = $this->safe_integer($targetCurrency, 'precision');
            $orderLockedAmount = 0;
            if ($orderSide === 'Ask') {
                $orderLockedAmount = $orderAmount * $lotSize / pow(10, $targetCurrencyPrecision);
            } elseif ($orderSide === 'Bid') {
                $orderLockedAmount = $orderAmount * $orderPrice * $lotSize / pow(10, $targetCurrencyPrecision);
            }
            $used[$targetToken] .= $orderLockedAmount;
            $free[$targetToken] = $total[$targetToken] - $used[$targetToken];
        }
        for ($i = 0; $i < $this->count_items($total); $i++) { // For when an $asset does not have any values locked in orders.
            $targetToken = is_array($total) ? array_keys($total) : array()[$i];
            if ($this->safe_value($free, $targetToken) === 0) {
                $targetTokenTotalAmount = $this->safe_value($total, $targetToken);
                $free[$targetToken] = $targetTokenTotalAmount;
            }
        }
        $timestamp = $this->milliseconds();
        $balanceResult = array(
            'info' => array(
                'balances' => $result,
                'openOrders' => $openOrders,
                'filledUnsettledOrders' => $filledUnsettledOrders,
            ),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'free' => $free,
            'used' => $used,
            'total' => $total,
        );
        for ($i = 0; $i < $this->count_items($total); $i++) {
            $assetSymbol = is_array($total) ? array_keys($total) : array()[$i];
            $assetBalances = array(
                'free' => $this->safe_number($free, $assetSymbol),
                'used' => $this->safe_number($used, $assetSymbol),
                'total' => $this->safe_number($total, $assetSymbol),
            );
            $balanceResult[$assetSymbol] = $assetBalances;
        }
        return $this->safe_balance($balanceResult);
    }

    public function create_order(string $symbol, string $type, string $side, float $amount, ?float $price = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $type, $side, $amount, $price, $params) {
            $meta = Async\await($this->fetch_market_meta($symbol));
            $symbol = $this->safe_string($meta, 'symbol');
            $marketId = $this->safe_string($meta, 'marketId');
            $market = $this->safe_dict($meta, 'market');
            $rawMarketId = $this->safe_integer($this->safe_dict($market, 'info'), 'marketId');
            $quantityTickSize = $this->safe_number($this->safe_dict($market, 'info'), 'quantityTickSize');
            $exchangeAmount = null;
            if ($quantityTickSize && $quantityTickSize !== 0) {
                $exchangeAmount = $this->parse_to_int($amount / $quantityTickSize);
            }
            $exchangeOrderType = null;
            if ($type === 'limit') {
                $exchangeOrderType = 0;
            } elseif ($type === 'market') {
                $exchangeOrderType = 1;
            } elseif ($type === 'MARKET_WITH_PROTECTION') {
                $exchangeOrderType = 2;
            } else {
                throw new InvalidOrder('OrderType was not recognized => ' . $type);
            }
            $exchangeOrderSide = null;
            if ($side === 'buy') {
                $exchangeOrderSide = 0;
            } elseif ($side === 'sell') {
                $exchangeOrderSide = 1;
            } else {
                throw new InvalidOrder('OrderSide was not recognized => ' . $side);
            }
            $timestamp = $this->milliseconds();
            $clientOrderId = $this->safe_integer($params, 'clientOrderId', $timestamp);
            $request = array(
                'clientOrderId' => $clientOrderId,
                'requestId' => $this->safe_integer($params, 'requestId', 1),
                'marketId' => $rawMarketId,
                'quantity' => $exchangeAmount,
                'side' => $exchangeOrderSide,
                'timeInForce' => $this->safe_integer($params, 'timeInForce', 1),
                'orderType' => $exchangeOrderType,
                'selfTradePrevention' => $this->safe_integer($params, 'selfTradePrevention', 0),
                'postOnly' => $this->safe_integer($params, 'postOnly', 0),
                'cancelOnDisconnect' => $this->safe_bool($params, 'cancelOnDisconnect', false),
            );
            $priceTickSize = $this->parse_to_numeric($this->safe_value($this->safe_dict($market, 'info'), 'priceTickSize'));
            if ($price !== null) {
                $lamportPrice = null;
                if ($priceTickSize && $priceTickSize !== 0) {
                    $lamportPrice = $this->parse_to_int($price / $priceTickSize);
                }
                $request['price'] = $lamportPrice;
            }
            $this->inject_sub_account_id($request, $params);
            $response = Async\await($this->restOsmiumPrivatePostOrder ($this->extend($request, $params)));
            $this->validate_create_order_response($response);
            $order = $this->safe_dict($this->safe_dict($response, 'result'), 'Ack');
            $exchangeOrderId = $this->safe_string($order, 'exchangeOrderId');
            $fetchedOrder = Async\await($this->fetch_raw_order($exchangeOrderId, $marketId));
            $orderStatus = 'open';
            if (!$fetchedOrder) {
                $orderStatus = $order ? 'filled' : 'rejected';
            }
            return $this->parse_order(array(
                'order' => $order,
                'fetchedOrder' => $fetchedOrder,
                'orderStatus' => $orderStatus,
                'transactionType' => 'creation',
            ), $market);
        }) ();
    }

    public function validate_create_order_response(array $response) {
        $result = $this->safe_dict($response, 'result');
        if (is_array($result) && array_key_exists('Ack', $result)) {
            return;
        }
        $rejection = $this->safe_dict($result, 'Rej');
        if ($rejection !== null) {
            $rejectReason = $this->safe_string($rejection, 'reason');
            if ($rejectReason !== null) {
                $this->handle_create_order_reject($rejectReason, $rejection);
            }
        }
        throw new InvalidOrder('Order $response is invalid => No Ack or Rej found.');
    }

    public function handle_create_order_reject(string $reason, array $order) {
        $clientOrderId = $this->safe_string($order, 'clientOrderId');
        $errorMessage = 'Order rejected for $clientOrderId ' . $clientOrderId . '. Reason => ';
        if ($reason === '0') {
            throw new InvalidOrder($errorMessage . 'Unclassified error occurred.');
        } elseif ($reason === '1') {
            throw new InvalidOrder($errorMessage . 'Invalid quantity => Quantity was zero.');
        } elseif ($reason === '2') {
            throw new InvalidOrder($errorMessage . 'Invalid market ID => The specified market ID does not exist.');
        } elseif ($reason === '3') {
            throw new InvalidOrder($errorMessage . 'Duplicate $order ID => The specified client $order ID was not unique among open orders for this subaccount.');
        } elseif ($reason === '4') {
            throw new InvalidOrder($errorMessage . 'Invalid side specified.');
        } elseif ($reason === '5') {
            throw new InvalidOrder($errorMessage . 'Invalid time in force specified.');
        } elseif ($reason === '6') {
            throw new InvalidOrder($errorMessage . 'Invalid $order type specified.');
        } elseif ($reason === '7') {
            throw new InvalidOrder($errorMessage . 'Invalid post-only flag specified.');
        } elseif ($reason === '8') {
            throw new InvalidOrder($errorMessage . 'Invalid self-trade prevention specified.');
        } elseif ($reason === '9') {
            throw new InvalidOrder($errorMessage . 'Unknown trader => Internal error with subaccount positions.');
        } elseif ($reason === '10') {
            throw new InvalidOrder($errorMessage . 'Price should not be specified for market or market limit orders.');
        } elseif ($reason === '11') {
            throw new InvalidOrder($errorMessage . 'Post-only with market $order is not allowed.');
        } elseif ($reason === '12') {
            throw new InvalidOrder($errorMessage . 'Post-only with invalid time in force.');
        } elseif ($reason === '13') {
            throw new InvalidOrder($errorMessage . 'Exceeded spot position limits.');
        } elseif ($reason === '14') {
            throw new InvalidOrder($errorMessage . 'No opposing resting orders to trade against.');
        } elseif ($reason === '15') {
            throw new InvalidOrder($errorMessage . 'Post-only $order would have crossed and traded.');
        } elseif ($reason === '16') {
            throw new InvalidOrder($errorMessage . 'Fill or kill (FOK) $order was not fully fillable.');
        } elseif ($reason === '17') {
            throw new InvalidOrder($errorMessage . 'Only $order cancelations are accepted at this time.');
        } elseif ($reason === '18') {
            throw new InvalidOrder($errorMessage . 'Protection price would not trade for market-with-protection orders.');
        } elseif ($reason === '19') {
            throw new InvalidOrder($errorMessage . 'Market orders cannot be placed because there is no internal reference price.');
        } elseif ($reason === '20') {
            throw new InvalidOrder($errorMessage . 'Slippage too high => The $order would trade beyond allowed protection levels.');
        } elseif ($reason === '21') {
            throw new InvalidOrder($errorMessage . 'Outside price band => Bid price is too low or ask price is too high.');
        } else {
            throw new InvalidOrder($errorMessage . 'Unknown $reason code => ' . $reason . '.');
        }
    }

    public function cancel_order(string $id, ?string $symbol = null, $params = array ()) {
        return Async\async(function () use ($id, $symbol, $params) {
            $meta = Async\await($this->fetch_market_meta($symbol));
            $symbol = $this->safe_string($meta, 'symbol');
            $marketId = $this->safe_string($meta, 'marketId');
            $market = $this->safe_dict($meta, 'market');
            $rawMarketId = $this->safe_integer($this->safe_dict($market, 'info'), 'marketId');
            $fetchedOrder = Async\await($this->fetch_raw_order($id, $marketId));
            if (!$fetchedOrder) {
                $fetchedOrder = array();
            }
            $clientOrderId = $this->safe_integer($fetchedOrder, 'clientOrderId');
            $request = array(
                'clientOrderId' => $clientOrderId,
                'requestId' => $this->safe_integer($params, 'requestId', 1),
                'marketId' => $rawMarketId,
            );
            $this->inject_sub_account_id($request, $params);
            $response = Async\await($this->restOsmiumPrivateDeleteOrder ($this->extend($request, $params)));
            $this->validate_cancel_order_response($response, $fetchedOrder);
            return $this->parse_order(array(
                'cancellationResponse' => $response,
                'fetchedOrder' => $fetchedOrder,
                'transactionType' => 'cancellation',
            ), $market);
        }) ();
    }

    public function validate_cancel_order_response(array $response, array $order) {
        $result = $this->safe_dict($response, 'result');
        if (is_array($result) && array_key_exists('Ack', $result)) {
            $ack = $this->safe_dict($result, 'Ack');
            $reason = $this->safe_string($ack, 'reason');
            if ($reason !== null) {
                $this->handle_cancel_order_ack($reason, $ack);
            }
            return;
        }
        $rejection = $this->safe_dict($result, 'Rej');
        if ($rejection) {
            $rejectReason = $this->safe_string($rejection, 'reason');
            if ($rejectReason !== null) {
                $this->handle_cancel_order_reject($rejectReason, $order);
            }
        }
        throw new InvalidOrder('Cancel $order $response is invalid => No Ack or Rej found.');
    }

    public function handle_cancel_order_reject(string $reason, array $order) {
        $clientOrderId = $this->safe_string($order, 'clientOrderId');
        $errorMessage = 'Order cancellation rejected for clientOrderId' . $clientOrderId . 'Reason => ';
        if ($reason === '0') {
            throw new InvalidOrder($errorMessage . 'Unclassified error occurred.');
        } elseif ($reason === '1') {
            throw new InvalidOrder($errorMessage . 'Invalid market ID => The specified market ID does not exist.');
        } elseif ($reason === '2') {
            throw new InvalidOrder($errorMessage . 'Order not found => The specified client $order ID does not exist for the corresponding market ID and subaccount ID.');
        } else {
            throw new InvalidOrder($errorMessage . 'Unknown $reason code => ' . $reason . '.');
        }
    }

    public function handle_cancel_order_ack(string $reason, array $ack) {
        $clientOrderId = $this->safe_string($ack, 'clientOrderId');
        $errorMessage = 'Order rejected for $clientOrderId ' . $clientOrderId . '. Reason => ';
        if ($reason === '0') {
            throw new InvalidOrder($errorMessage . 'Unclassified acknowledgment.');
        } elseif ($reason === '1') {
            throw new InvalidOrder($errorMessage . 'Order canceled due to disconnection.');
        } elseif ($reason === '2') {
            throw new InvalidOrder($errorMessage . 'Order was requested to be canceled.');
        } elseif ($reason === '3') {
            throw new InvalidOrder($errorMessage . 'Immediate or cancel (IOC) order was not fully filled.');
        } elseif ($reason === '4') {
            throw new InvalidOrder($errorMessage . 'A resting order was canceled due to self-trade prevention (STP).');
        } elseif ($reason === '5') {
            throw new InvalidOrder($errorMessage . 'An aggressing order was canceled due to self-trade prevention (STP).');
        } elseif ($reason === '6') {
            throw new InvalidOrder($errorMessage . 'Order was covered by a mass-cancel request.');
        } elseif ($reason === '7') {
            throw new InvalidOrder($errorMessage . 'Order was canceled because asset position limits would be otherwise breached.');
        } else {
            throw new InvalidOrder($errorMessage . 'Unknown acknowledgment $reason code:' . $reason . '.');
        }
    }

    public function cancel_all_orders(?string $symbol = null, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            /**
             * cancel all open orders
             * @see https://cubexch.gitbook.io/cube-api/rest-osmium-api#orders-1
             * @param {string} $symbol cube cancelAllOrders cannot setting $symbol, it will cancel all open orders
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            $meta = Async\await($this->fetch_market_meta($symbol));
            $symbol = $this->safe_string($meta, 'symbol');
            $market = $this->safe_dict($meta, 'market');
            $rawMarkeId = $this->safe_integer($this->safe_dict($market, 'info'), 'marketId');
            $request = array(
                'marketId' => $rawMarkeId,
                'requestId' => $this->safe_integer($params, 'requestId', 1),
                'side' => $this->safe_integer($params, 'side', null),
            );
            $this->inject_sub_account_id($request, $params);
            $response = Async\await($this->restOsmiumPrivateDeleteOrders ($this->extend($request, $params)));
            return array(
                'info' => $this->safe_dict($response, 'result'),
                'market' => $market,
            );
        }) ();
    }

    public function fetch_order(string $id, ?string $symbol = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($id, $symbol, $params) {
            /**
             * fetches information on an $order made by the user
             * @see https://cubexch.gitbook.io/cube-api/rest-osmium-api#orders
             * @param {string} $symbol unified $symbol of the $market the $order was made in
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} An ~@link https://docs.ccxt.com/#/?$id=$order-structure $order structure~
             */
            $meta = Async\await($this->fetch_market_meta($symbol));
            $symbol = $this->safe_string($meta, 'symbol');
            $market = $this->safe_dict($meta, 'market');
            $order = Async\await($this->fetch_raw_order($id, $symbol, $params));
            //
            //  {
            //      "result" => {
            //          "orders" => array(
            //              array(
            //                  "clientOrderId" => 1713422528124,
            //                  "exchangeOrderId" => 1295024967,
            //                  "marketId" => 100006,
            //                  "price" => 11000,
            //                  "orderQuantity" => 1,
            //                  "side" => 0,
            //                  "timeInForce" => 1,
            //                  "orderType" => 0,
            //                  "remainingQuantity" => 1,
            //                  "restTime" => 1713422528222471490,
            //                  "subaccountId" => 38393,
            //                  "cumulativeQuantity" => 0,
            //                  "cancelOnDisconnect" => false
            //              ),
            //              ...
            //          )
            //      }
            //  }
            //
            return $this->parse_order(
                array(
                    'fetchedOrder' => $order,
                    'transactionType' => 'fetching',
                ),
                $market
            );
        }) ();
    }

    public function fetch_raw_order(string $id, $symbol = null, $params = array ()) {
        return Async\async(function () use ($id, $symbol, $params) {
            /**
             * fetches information on an $order made by the user
             * @see https://cubexch.gitbook.io/cube-api/rest-osmium-api#orders
             * @param {string} $symbol unified $symbol of the market the $order was made in
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} An ~@link https://docs.ccxt.com/#/?$id=$order-structure $order structure~
             */
            $meta = Async\await($this->fetch_market_meta($symbol));
            $symbol = $this->safe_string($meta, 'symbol');
            $request = array();
            $this->inject_sub_account_id($request, $params);
            $rawResponse = Async\await($this->restOsmiumPrivateGetOrders ($this->extend($request, $params)));
            //
            // {
            //    "result" => {
            //        "orders" => array(
            //            array(
            //                "clientOrderId" => 1713422528124,
            //                "exchangeOrderId" => 1295024967,
            //                "marketId" => 100006,
            //                "price" => 11000,
            //                "orderQuantity" => 1,
            //                "side" => 0,
            //                "timeInForce" => 1,
            //                "orderType" => 0,
            //                "remainingQuantity" => 1,
            //                "restTime" => 1713422528222471490,
            //                "subaccountId" => 38393,
            //                "cumulativeQuantity" => 0,
            //                "cancelOnDisconnect" => false
            //            ),
            //            ...
            //        )
            //    }
            // }
            //
            $result = $this->safe_list($this->safe_dict($rawResponse, 'result'), 'orders');
            $order = null;
            for ($i = 0; $i < $this->count_items($result); $i++) {
                $clientOrderId = $this->safe_string($result[$i], 'clientOrderId');
                $exchangeOrderId = $this->safe_string($result[$i], 'exchangeOrderId');
                if ($id === $clientOrderId || $id === $exchangeOrderId) {
                    $order = $result[$i];
                    break;
                }
            }
            return $order;
        }) ();
    }

    public function fetch_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetch all unfilled currently open orders
             * @param {string} $symbol unified $market $symbol of the $market orders were made in
             * @param {int} [$since] the earliest time in ms to fetch orders for
             * @param {int} [$limit] the maximum number of order structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {Order[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            $meta = Async\await($this->fetch_market_meta($symbol));
            $market = $this->safe_market($this->safe_string($meta, 'marketId'), $this->safe_dict($meta, 'market'), '/');
            $rawOrders = Async\await($this->fetch_raw_orders());
            return $this->parse_orders($rawOrders, $market, $since, $limit);
        }) ();
    }

    public function parse_orders(array $orders, ?array $market = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        //
        // the value of $orders is either a dict or a list
        //
        // dict
        //
        //     {
        //         'id1' => array( ... ),
        //         'id2' => array( ... ),
        //         'id3' => array( ... ),
        //         ...
        //     }
        //
        // list
        //
        //     array(
        //         array( 'id' => 'id1', ... ),
        //         array( 'id' => 'id2', ... ),
        //         array( 'id' => 'id3', ... ),
        //         ...
        //     )
        //
        $results = array();
        if (gettype($orders) === 'array' && array_keys($orders) === array_keys(array_keys($orders))) {
            for ($i = 0; $i < count($orders); $i++) {
                $order = $this->extend($this->parse_order(array( 'fetchedOrder' => $orders[$i], 'transactionType' => 'fetching_all' ), $market), $params);
                $results[] = $order;
            }
        } else {
            $ids = is_array($orders) ? array_keys($orders) : array();
            for ($i = 0; $i < count($ids); $i++) {
                $id = $ids[$i];
                $order = $this->extend($this->parse_order(array( 'fetchedOrder' => $orders[$id], 'transactionType' => 'fetching_all' ), $market), $params);
                $results[] = $order;
            }
        }
        $results = $this->sort_by($results, 'timestamp');
        $symbol = null;
        if ($market !== null) {
            $symbol = $market['symbol'];
        }
        return $this->filter_by_symbol_since_limit($results, $symbol, $since, $limit);
    }

    public function parse_order($order, ?array $market = null) {
        $transactionType = $this->safe_string($order, 'transactionType');
        $fetchedOrder = $this->safe_dict($order, 'fetchedOrder');
        $orderStatus = null;
        if ($transactionType === 'creation') {
            $orderStatus = $this->safe_string($order, 'orderStatus');
            if ($orderStatus === 'rejected') {
                throw new InvalidOrder('Order was rejected');
            }
            if ($orderStatus === 'filled') {
                $fetchedOrder = $this->safe_dict($order, 'order');
            }
        } elseif ($transactionType === 'cancellation') {
            $orderStatus = 'canceled';
        } elseif ($transactionType === 'fetching') {
            $orderStatus = 'open'; // If the $order is fetched, it is open
        } elseif ($transactionType === 'fetching_all') {
            $orderStatus = $this->safe_string($fetchedOrder, 'status'); // The $order status is present in the $order body when fetching the endpoint of all orders
        }
        if ($fetchedOrder !== null) {
            if (!$market) {
                $market = $this->options['mappings']['rawMarketsIdsToMarkets'][$this->parse_to_numeric($fetchedOrder['marketId'])];
            }
            $exchangeOrderId = $this->safe_string($fetchedOrder, 'exchangeOrderId');
            $clientOrderId = $this->safe_string($fetchedOrder, 'clientOrderId');
            $timestampInNanoseconds = null;
            $timestampInNanoseconds = $this->safe_integer($fetchedOrder, 'restTime');
            if ($timestampInNanoseconds === null) {
                $timestampInNanoseconds = $this->safe_integer($fetchedOrder, 'transactTime');
            }
            if ($timestampInNanoseconds === null) {
                $timestampInNanoseconds = $this->safe_integer($fetchedOrder, 'createdAt');
            }
            if ($timestampInNanoseconds === null) {
                $timestampInNanoseconds = $this->safe_integer($fetchedOrder, 'filledAt');
            }
            if ($timestampInNanoseconds === null) {
                $timestampInNanoseconds = $this->safe_integer($fetchedOrder, 'canceledAt');
            }
            $timestampInMilliseconds = $this->parse_to_int($timestampInNanoseconds / 1000000);
            $symbol = $this->safe_string($market, 'symbol');
            $orderSideRaw = $this->safe_integer($fetchedOrder, 'side');
            $orderSide = null;
            if ($orderSideRaw === 0) {
                $orderSide = 'buy';
            } else {
                $orderSide = 'sell';
            }
            $currency = null;
            if ($orderSide === 'buy') {
                $currency = $this->safe_string($market, 'base');
            } else {
                $currency = $this->safe_string($market, 'quote');
            }
            $orderTypeRaw = $this->safe_integer($fetchedOrder, 'orderType');
            $orderType = null;
            if ($orderTypeRaw === 0) {
                $orderType = 'limit';
            } elseif ($orderTypeRaw === 1) {
                $orderType = 'market';
            } elseif ($orderTypeRaw === 2) {
                $orderType = 'MARKET_WITH_PROTECTION';
            }
            $timeInForce = null;
            $timeInForceRaw = $this->safe_integer($fetchedOrder, 'timeInForce');
            if ($timeInForceRaw === 0) {
                $timeInForce = 'IOC';
            } elseif ($timeInForceRaw === 1) {
                $timeInForce = 'GTC';
            } elseif ($timeInForceRaw === 2) {
                $timeInForce = 'FOK';
            }
            $priceTickSize = $this->parse_to_numeric($this->safe_value($this->safe_dict($market, 'info'), 'priceTickSize'));
            $rawPrice = $this->safe_integer($fetchedOrder, 'price');
            $price = null;
            if ($rawPrice === null || $orderType === 'market') {
                $price = 0;
            } else {
                if ($priceTickSize && $priceTickSize !== 0) {
                    $price = $rawPrice * $priceTickSize;
                }
            }
            $amount = null;
            $amount = $this->safe_integer($fetchedOrder, 'quantity');
            if ($amount === null) {
                $amount = $this->safe_integer($fetchedOrder, 'qty');
            }
            if ($amount === null) {
                $amount = $this->safe_integer($fetchedOrder, 'orderQuantity');
            }
            $remainingAmount = null;
            $remainingAmount = $this->safe_integer($fetchedOrder, 'remainingQuantity');
            if ($remainingAmount === null && ($orderStatus === 'canceled' || $orderStatus === 'filled')) {
                $remainingAmount = $amount;
            }
            if ($remainingAmount === null) {
                $remainingAmount = 0;
            }
            $filledAmount = $amount - $remainingAmount;
            $tradeFeeRatios = $this->safe_dict($this->fees, 'trading');
            $rate = null;
            if ($orderSide === 'buy') {
                $rate = $this->safe_number($tradeFeeRatios, 'maker');
            } elseif ($orderSide === 'sell') {
                $rate = $this->safe_number($tradeFeeRatios, 'taker');
            }
            $quantityTickSize = $this->parse_to_numeric($this->safe_value($this->safe_dict($market, 'info'), 'quantityTickSize'));
            $decimalAmount = 0;
            $decimalFilledAmount = 0;
            $decimalRemainingAmount = 0;
            if ($quantityTickSize && $quantityTickSize !== 0) {
                $decimalAmount = $amount * $quantityTickSize;
                $decimalFilledAmount = $filledAmount * $quantityTickSize;
                $decimalRemainingAmount = $remainingAmount * $quantityTickSize;
            }
            $cost = $decimalFilledAmount * $price;
            $feeCost = $decimalAmount * $rate;
            // $average = null;
            // if ($price !== null && (string) explode('.', strlen($price)) === 1) {
            //     $average = (string) $this->parse_to_numeric($price . '.0000001');
            // } else {
            //     $average = $price;
            // }
            $finalOrder = array(
                'id' => $exchangeOrderId,
                'clientOrderId' => $clientOrderId,
                'datetime' => $this->iso8601($timestampInMilliseconds),
                'timestamp' => $timestampInMilliseconds,
                'lastTradeTimestamp' => $timestampInMilliseconds,
                'status' => $orderStatus,
                'symbol' => $symbol,
                'type' => $orderType,
                'timeInForce' => $timeInForce,
                'side' => $orderSide,
                'price' => $price,
                'average' => null,
                'amount' => $decimalAmount,
                'filled' => $decimalFilledAmount,
                'remaining' => $decimalRemainingAmount,
                'cost' => $cost,
                'trades' => array(),
                'fee' => array(
                    'currency' => $currency, // a deduction from the asset hasattr($this, received) trade
                    'cost' => $feeCost,
                    'rate' => $rate,
                ),
                'info' => array(
                    'fetchedOrder' => $fetchedOrder,
                ),
            );
            $finalOrder['fees'] = $this->safe_dict($finalOrder, 'fee');
            return $this->safe_order($finalOrder);
        } else {
            throw new OrderNotFound('Order not found');
        }
    }

    public function fetch_open_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetch all unfilled currently open orders
             * @param {string} $symbol unified $market $symbol of the $market orders were made in
             * @param {int} [$since] the earliest time in ms to fetch orders for
             * @param {int} [$limit] the maximum number of order structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {Order[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            $meta = Async\await($this->fetch_market_meta($symbol));
            $market = $this->safe_dict($meta, 'market');
            $request = array();
            $this->inject_sub_account_id($request, $params);
            $response = Async\await($this->restOsmiumPrivateGetOrders ($this->extend($request, $params)));
            $rawOrders = $this->safe_list($this->safe_dict($response, 'result'), 'orders');
            return $this->parse_orders($rawOrders, $market, $since, $limit);
        }) ();
    }

    public function fetch_raw_orders() {
        return Async\async(function ()  {
            /**
             * fetch all orders from all markets
             * @param {string} symbol unified market symbol of the market orders were made in
             * @param {int} [since] the earliest time in ms to fetch orders for
             * @param {int} [limit] the maximum number of order structures to retrieve
             * @param {array} [params] extra parameters specific to the exchange API endpoint
             * @return {Order[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            $request = array();
            $this->inject_sub_account_id($request, array());
            $response = Async\await($this->restIridiumPrivateGetUsersSubaccountSubaccountIdOrders ($this->extend($request)));
            $rawOrders = $this->safe_list($this->safe_dict($response, 'result'), 'orders');
            return $rawOrders;
        }) ();
    }

    public function fetch_trades(string $symbol, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * get the list of most recent trades for a particular $symbol
             * @see https://cubexch.gitbook.io/cube-api/rest-mendelev-api#book-market_id-recent-trades
             * @see https://cubexch.gitbook.io/cube-api/rest-mendelev-api#parsed-book-market_symbol-recent-trades
             * @param {string} $symbol unified $symbol of the $market to fetch trades for
             * @param {int} [$since] timestamp in ms of the earliest trade to fetch
             * @param {int} [$limit] the maximum number of trades to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {int} $params->lastId order id
             * @return {Trade[]} a list of ~@link https://docs.ccxt.com/#/?id=public-trades trade structures~
             */
            $meta = Async\await($this->fetch_market_meta($symbol));
            $symbol = $this->safe_string($meta, 'symbol');
            $market = $this->safe_dict($meta, 'market');
            $rawMarketId = $this->safe_string($this->safe_dict($market, 'info'), 'marketId');
            $rawMarketSymbol = $this->safe_string($this->safe_dict($market, 'info'), 'symbol');
            $request = null;
            $request = array(
                'market_id' => $rawMarketId,
            );
            $recentTradesResponse = Async\await($this->restMendelevPublicGetBookMarketIdRecentTrades ($this->extend($request, $params)));
            //
            // {
            //     "result":{
            //         "trades":array(
            //             array(
            //                 "tradeId":1192726,
            //                 "price":25730,
            //                 "aggressingSide":1,
            //                 "restingExchangeOrderId":775000423,
            //                 "fillQuantity":2048,
            //                 "transactTime":1710261845127064300,
            //                 "aggressingExchangeOrderId":775000298
            //             ),
            //             {
            //                 "tradeId":1192723,
            //                 "price":25730,
            //                 "aggressingSide":0,
            //                 "restingExchangeOrderId":775000298,
            //                 "fillQuantity":5000,
            //                 "transactTime":1710261844303742500,
            //                 "aggressingExchangeOrderId":774996895
            //             }
            //         )
            //     }
            // }
            //
            $request = array(
                'market_symbol' => $rawMarketSymbol,
            );
            $parsedRecentTradesResponse = Async\await($this->restMendelevPublicGetParsedBookMarketSymbolRecentTrades ($this->extend($request, $params)));
            //
            // {
            //     "result":{
            //         "ticker_id":"BTCUSDC",
            //         "trades":array(
            //             array(
            //                 "id":1106939,
            //                 "p":63565.6,
            //                 "q":0.01,
            //                 "side":"Ask",
            //                 "ts":1711153560907
            //             ),
            //             {
            //                 "id":1107084,
            //                 "p":63852.9,
            //                 "q":0.01,
            //                 "side":"Bid",
            //                 "ts":1711156552440
            //             }
            //         )
            //     }
            // }
            //
            $tradesAndParsedTrades = array(
                'trades' => $this->safe_list($this->safe_dict($recentTradesResponse, 'result'), 'trades'),
                'parsedTrades' => $this->safe_list($this->safe_dict($parsedRecentTradesResponse, 'result'), 'trades'),
            );
            $rawTrades = array( $tradesAndParsedTrades );
            $parsedTrades = $this->parse_trades($rawTrades, $market);
            return $this->filter_by_symbol_since_limit($parsedTrades, $symbol, $since, $limit);
        }) ();
    }

    public function parse_trades($trades, ?array $market = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        $parsedTrades = $this->safe_value($trades[0], 'parsedTrades');
        $finalTrades = array();
        if ($parsedTrades !== null && $this->count_items($parsedTrades) > 0) {
            for ($i = 0; $i < $this->count_items($parsedTrades); $i++) {
                $trade = $parsedTrades[$i];
                $finalTrades[] = $this->parse_trade($trade, $market);
            }
        }
        return $finalTrades;
    }

    public function parse_trade($trade, $market = null) {
        $timestampSeconds = 0;
        if ($trade['ts'] !== null) {
            $timestampSeconds = $this->safe_integer($trade, 'ts');
        } elseif ($trade['transactTime'] !== null) {
            $timestampNanoseconds = $trade['transactTime'];
            $timestampSeconds = $timestampNanoseconds / 1000000;
        }
        $datetime = $this->iso8601($timestampSeconds);
        $tradeSide = $this->safe_string($trade, 'side');
        $side = '';
        if ($tradeSide === 'Bid') {
            $side = 'buy';
        } elseif ($tradeSide === 'Ask') {
            $side = 'sell';
        }
        $marketSymbol = $this->safe_string($market, 'symbol');
        $price = floatval($this->safe_string($trade, 'p'));
        $amount = floatval($this->safe_string($trade, 'q'));
        return $this->safe_trade(array(
            'info' => $trade,
            'timestamp' => $timestampSeconds,
            'datetime' => $datetime,
            'symbol' => $marketSymbol,
            'id' => $this->safe_string($trade, 'id'),
            'order' => null,
            'type' => null,
            'takerOrMaker' => null,
            'side' => $side,
            'price' => $price,
            'amount' => $amount,
            'cost' => null,
            'fee' => null,
            'fees' => array(
                array(
                    'cost' => null,
                    'currency' => null,
                    'rate' => null,
                ),
            ),
        ), $market);
    }

    public function fetch_trading_fee(string $symbol, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $params) {
            /**
             * fetch the trading fees for a $market
             * @see https://cubexch.gitbook.io/cube-api/rest-iridium-api#users-fee-estimate-$market-id
             * @param {string} $symbol unified $market $symbol
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=fee-structure fee structure~
             */
            $meta = Async\await($this->fetch_market_meta($symbol));
            $symbol = $this->safe_string($meta, 'symbol');
            $market = $this->safe_dict($meta, 'market');
            $rawMarketId = $this->safe_integer($this->safe_dict($market, 'info'), 'marketId');
            $request = array(
                'market_id' => $rawMarketId,
            );
            $response = Async\await($this->restIridiumPrivateGetUsersFeeEstimateMarketId ($this->extend($request, $params)));
            // {
            //     "result" => {
            //         "userKey" => "123e4567-e89b-12d3-a456-426614174000",
            //         "makerFeeRatio" => 0,
            //         "takerFeeRatio" => 0
            //     }
            // }
            return array(
                'info' => $response,
                'symbol' => $symbol,
                'maker' => $this->safe_number($this->safe_dict($response, 'result'), 'makerFeeRatio'),
                'taker' => $this->safe_number($this->safe_dict($response, 'result'), 'takerFeeRatio'),
                'percentage' => null,
                'tierBased' => null,
            );
        }) ();
    }

    public function fetch_my_trades(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetch all trades made by the user
             * @see https://cubexch.gitbook.io/cube-api/rest-iridium-api#users-subaccount-subaccount_id-fills
             * @param {string} $symbol unified market $symbol
             * @param {int} [$since] the earliest time in ms to fetch trades for
             * @param {int} [$limit] the maximum number of trades structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {Trade[]} a list of ~@link https://docs.ccxt.com/#/?id=$trade-structure $trade structures~
             */
            $meta = Async\await($this->fetch_market_meta($symbol));
            $symbol = $this->safe_string($meta, 'symbol');
            $allOrders = Async\await($this->fetch_orders($symbol, $since, $limit, $params));
            $myTrades = array();
            for ($i = 0; $i < $this->count_items($allOrders); $i++) {
                $orderStatus = $this->safe_string($allOrders[$i], 'status');
                if ($orderStatus === 'filled') {
                    $orderFills = $this->safe_list($this->safe_dict($this->safe_dict($allOrders[$i], 'info'), 'fetchedOrder'), 'fills');
                    $fillsLength = $this->count_items($orderFills);
                    for ($j = 0; $j < $fillsLength; $j++) {
                        $trade = $orderFills[$j];
                        $parsedTrade = Async\await($this->parse_my_trade($trade, $allOrders[$i]));
                        $myTrades[] = $parsedTrade;
                    }
                }
            }
            return $this->filter_by_symbol_since_limit($myTrades, $symbol, $since, $limit);
        }) ();
    }

    public function parse_my_trade($trade, $order) {
        return Async\async(function () use ($trade, $order) {
            $tradeId = $this->safe_string($trade, 'tradeId');
            $timestampInNanoseconds = $this->safe_integer($trade, 'filledAt');
            $timestampInMilliseconds = $this->parse_to_int($timestampInNanoseconds / 1000000);
            $datetime = $this->iso8601($timestampInMilliseconds);
            $meta = Async\await($this->fetch_market_meta($this->safe_string($order, 'symbol')));
            $marketSymbol = $this->safe_string($meta, 'symbol');
            $orderType = $this->safe_string($order, 'type');
            $orderId = null;
            if ($orderType === 'limit') {
                $orderId = $this->safe_string($order, 'id');
            } elseif ($orderType === 'market') {
                $orderId = $this->safe_string($order, 'clientOrderId');
            }
            $orderSide = $this->safe_string($order, 'side');
            $timeInForce = $this->safe_string($order, 'timeInForce');
            $takerOrMaker = null;
            if ($orderType === 'market' || $timeInForce === 'IOC' || $timeInForce === 'FOK') {
                $takerOrMaker = 'taker';
            } else {
                $takerOrMaker = 'maker';
            }
            $orderPrice = $this->safe_number($order, 'price');
            $orderAmount = $this->safe_number($order, 'amount');
            $cost = null;
            if ($orderPrice !== null) {
                $cost = $orderPrice * $orderAmount;
            }
            $fee = $this->safe_dict($order, 'fee');
            $fees = $this->safe_list($order, 'fees');
            return array(
                'id' => $tradeId,
                'timestamp' => $timestampInMilliseconds,
                'datetime' => $datetime,
                'symbol' => $marketSymbol,
                'order' => $orderId,
                'type' => $orderType,
                'side' => $orderSide,
                'takerOrMaker' => $takerOrMaker,
                'price' => $orderPrice,
                'amount' => $orderAmount,
                'cost' => $cost,
                'fee' => $fee,
                'fees' => $fees,
                'info' => $order,
            );
        }) ();
    }

    public function fetch_closed_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetches a list of closed (or canceled) orders
             * @see https://github.com/ccxt/ccxt/wiki/Manual#understanding-the-orders-api-design
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {Order[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            $allOrders = Async\await($this->fetch_orders($symbol, $since, $limit, $params));
            $closedOrders = array();
            for ($i = 0; $i < $this->count_items($allOrders); $i++) {
                $orderStatus = $this->safe_string($allOrders[$i], 'status');
                if ($orderStatus === 'canceled' || $orderStatus === 'closed') {
                    $closedOrders[] = $allOrders[$i];
                }
            }
            return $closedOrders;
        }) ();
    }

    public function fetch_status($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * the latest known information on the availability of the exchange API
             * @see https://binance-docs.github.io/apidocs/spot/en/#system-status-system
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=exchange-status-structure status structure~
             */
            $response = Async\await($this->restIridiumPublicGetMarkets ($params));
            $keys = is_array($response) ? array_keys($response) : array();
            $keysLength = count($keys);
            $formattedStatus = null;
            if ($keysLength) {
                $formattedStatus = 'ok';
            } else {
                $formattedStatus = 'maintenance';
            }
            return array(
                'status' => $formattedStatus,
                'updated' => null,
                'eta' => null,
                'url' => null,
                'info' => null,
            );
        }) ();
    }

    public function fetch_deposits(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetch all $deposits made to an account
             * @param {string} code unified $currency code
             * @param {int} [$since] the earliest time in ms to fetch $deposits for
             * @param {int} [$limit] the maximum number of $deposits structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=transaction-structure transaction structures~
             */
            Async\await($this->fetch_market_meta());
            $request = array();
            $currency = null;
            if ($symbol !== null) {
                $currency = $this->currency($symbol);
                $request['asset_symbol'] = $this->safe_string($this->safe_dict($currency, 'info'), 'assetId');
            }
            if ($limit !== null) {
                $request['limit'] = $limit;
            }
            $this->inject_sub_account_id($request, $params);
            $subAccountId = $this->safe_string($request, 'subaccountId');
            $response = Async\await($this->restIridiumPrivateGetUsersSubaccountSubaccountIdDeposits ($this->extend($request, $params)));
            //
            // result => array(
            //     "161" => array(
            //       name => "primary",
            //       inner => array(
            //         array(
            //           assetId => 80005,
            //           amount => "5000000000",
            //           txnHash => "5E8xrkpCdwsczNDqGcezQ6agxDoFjXN9YVQFE4ZDk7vcdmdQHbPRSw7z3F769kkg4F57Vh4HsAsaKeFt8Z7qHhjZ",
            //           txnIndex => 1,
            //           createdAt => "2024-03-27T23:51:14.933108Z",
            //           updatedAt => "2024-03-27T23:51:28.93706Z",
            //           txnState => "confirmed",
            //           kytStatus => "accept",
            //           address => "79xoQgxNgKbjDrwp3Gb6t1oc1NmcgZ3PQFE7i1XCrk5x",
            //           fiatToCrypto => false,
            //         ),
            //       ),
            //     ),
            //   ),
            //
            $deposits = $this->safe_list($this->safe_dict($this->safe_dict($response, 'result'), $subAccountId), 'inner', array());
            for ($i = 0; $i < count($deposits); $i++) {
                $deposits[$i]['type'] = 'deposit';
            }
            return $this->parse_transactions($deposits, $currency, $since, $limit, $params);
        }) ();
    }

    public function fetch_deposit_addresses(?array $codes = null, $params = array ()) {
        return Async\async(function () use ($codes, $params) {
            /**
             * fetch deposit $addresses for multiple currencies and chain types
             * @see https://cubexch.gitbook.io/cube-api/rest-iridium-api#users-info
             * @param {string[]|null} $codes list of unified $currency $codes, default is null
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a list of ~@link https://docs.ccxt.com/#/?id=$address-structure $address structure~
             */
            Async\await($this->fetch_market_meta());
            $rawUsersInfoResponse = Async\await($this->restIridiumPrivateGetUsersInfo ($params));
            $rawMarketsResponse = Async\await($this->restIridiumPublicGetMarkets ($params));
            //
            // getUsersInfo
            // {
            //     ...
            //     "subaccounts" => array(
            //         {
            //             "id" => 161,
            //             "name" => "primary",
            //             "addresses" => array(
            //                 "101" => "tb1p74t28ne95z0rptyhqfwzx8xh2xclw4t2ua46fyzqr6x76km7sp8qdy2n3e",
            //                 "103" => "Cz3BnXPhYudZscqHHh5eDusYzVn4Bpb5EKBvrG4Zvaf3",
            //                 "105" => "nf8FjTqGW4B7Bx5UZhkRUhaGGnMjZ7LUPw",
            //                 "106" => "5G6AHKi87NCNkFvPfXx4aX3qLcoKzWRTK4KcHNPeVPB6qZyT",
            //                 "107" => "tltc1qwlky3uxaygw4g3yr39cw0xvzw323xynmunuca3",
            //                 "108" => "cosmos1wlky3uxaygw4g3yr39cw0xvzw323xynme8m7jx"
            //             ),
            //             "hasOrderHistory" => true
            //         }
            //     )
            //     ...
            // }
            //
            // getMarkets
            // {
            //     ...
            //     $sources => array(
            //        array(
            //            $sourceId => 1,
            //            name => "bitcoin",
            //            transactionExplorer => "https://mempool.space/tx/array()",
            //            addressExplorer => "https://mempool.space/address/array()",
            //            metadata => array(
            //              $network => "Mainnet",
            //              scope => "bitcoin",
            //              type => "mainnet",
            //           ),
            //        ),
            //     )
            //     ...
            // }
            if ($codes === null) {
                $codes = array();
            }
            $newCodes = array();
            for ($i = 0; $i < count($codes); $i++) {
                $newCodes[$i] = strtoupper($codes[$i]);
            }
            $codes = $newCodes;
            $sourcesByIds = array();
            $sources = $this->safe_list($rawMarketsResponse, 'sources', array());
            for ($i = 0; $i < count($sources); $i++) {
                $source = $sources[$i];
                $sourceId = $this->safe_string($source, 'sourceId');
                $sourcesByIds[$sourceId] = $source;
            }
            $subAccounts = $this->safe_list($rawUsersInfoResponse, 'subaccounts', array());
            $result = array(
                'info' => array(
                    'subaccounts' => $subAccounts,
                    'sources' => $sources,
                ),
            );
            for ($i = 0; $i < count($subAccounts); $i++) {
                $subAccount = $subAccounts[$i];
                $subAccountId = $this->safe_string($subAccount, 'id');
                $addresses = $this->safe_list($subAccount, 'addresses', array());
                $sourcesIds = is_array($addresses) ? array_keys($addresses) : array();
                for ($j = 0; $j < count($sourcesIds); $j++) {
                    $sourceId = $sourcesIds[$j];
                    $address = $addresses[$sourceId];
                    $this->check_address($address);
                    $source = $this->safe_string($sourcesByIds, $sourceId);
                    $currency = $this->currency($this->safe_string($source, 'name'));
                    $sourceMetaData = $this->safe_dict($source, 'metadata');
                    $network = $this->safe_string($sourceMetaData, 'scope') . '-' . $this->safe_string($sourceMetaData, 'type');
                    $currencyCode = $this->safe_string($currency, 'code');
                    if (!$this->in_array($currencyCode, $codes)) {
                        continue;
                    }
                    $result[$currencyCode] = array(
                        'info' => array(
                            'subaccount' => $subAccount,
                            'source' => $source,
                        ),
                        'currency' => $currencyCode,
                        'address' => $address,
                        'network' => $network,
                        'tag' => $subAccountId,
                    );
                }
            }
            return $result;
        }) ();
    }

    public function withdraw(string $code, float $amount, string $address, $tag = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($code, $amount, $address, $tag, $params) {
            /**
             * make a withdrawal
             * @see https://cubexch.gitbook.io/cube-api/rest-iridium-api#users-withdraw
             * @param {string} $code unified $currency $code
             * @param {float} $amount the $amount to withdraw
             * @param {string} $address the $address to withdraw to
             * @param {string} $tag
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=transaction-structure transaction structure~
             */
            list($tag, $params) = $this->handle_withdraw_tag_and_params($tag, $params);
            Async\await($this->fetch_market_meta());
            $currency = $this->currency($code);
            $currencyPrecision = $this->safe_integer($currency, 'precision');
            $exchangeAmount = (int) round($amount * pow(10, $currencyPrecision));
            $request = array(
                'amount' => $this->number_to_string($exchangeAmount),
                'destination' => $address,
                'assetId' => $this->safe_integer($currency, 'numericId'),
            );
            $this->inject_sub_account_id($request, $params);
            $response = Async\await($this->restIridiumPrivatePostUsersWithdraw ($this->extend($request, $params)));
            //
            // {
            //     "result" => {
            //       "status" => "pending",
            //       "approved" => false,
            //       "reason" => "text"
            //     }
            //     "result" => {
            //     "status" => "accept",
            //     "approved" => true
            //    }
            // }
            //
            return $response;
        }) ();
    }

    public function fetch_withdrawals(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetch all $withdrawals made from an account
             * @param {string} code unified $currency code
             * @param {int} [$since] the earliest time in ms to fetch $withdrawals for
             * @param {int} [$limit] the maximum number of $withdrawals structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=transaction-structure transaction structures~
             */
            Async\await($this->fetch_market_meta());
            $request = array();
            $currency = null;
            if ($symbol !== null) {
                $currency = $this->currency($symbol);
                $request['assetId'] = $currency['id'];
            }
            if ($limit !== null) {
                $request['limit'] = $limit;
            }
            $this->inject_sub_account_id($request, $params);
            $subAccountId = $this->safe_string($request, 'subaccountId');
            $response = Async\await($this->restIridiumPrivateGetUsersSubaccountSubaccountIdWithdrawals ($this->extend($request, $params)));
            //
            // result => array(
            //     "161" => array(
            //       name => "primary",
            //       inner => array(
            //         array(
            //           assetId => 80005,
            //           amount => "100000000",
            //           createdAt => "2024-05-02T18:03:36.779453Z",
            //           updatedAt => "2024-05-02T18:03:37.941902Z",
            //           attemptId => 208,
            //           address => "6khUqefutr3xA6fEUnZfRMRGwER8BBTZZFFgBPhuUyyp",
            //           kytStatus => "accept",
            //           approved => true,
            //         ),
            //       ),
            //     ),
            //   ),
            //
            $withdrawals = $this->safe_list($this->safe_dict($this->safe_dict($response, 'result'), $subAccountId), 'inner', array());
            for ($i = 0; $i < count($withdrawals); $i++) {
                $withdrawals[$i]['type'] = 'withdrawal';
            }
            return $this->parse_transactions($withdrawals, $currency, $since, $limit, $params);
        }) ();
    }

    public function parse_transaction($transaction, ?array $currency = null): array {
        //
        // fetchDeposits
        //
        // result => array(
        //     "161" => array(
        //       name => "primary",
        //       inner => array(
        //         array(
        //           assetId => 80005,
        //           $amount => "5000000000",
        //           txnHash => "5E8xrkpCdwsczNDqGcezQ6agxDoFjXN9YVQFE4ZDk7vcdmdQHbPRSw7z3F769kkg4F57Vh4HsAsaKeFt8Z7qHhjZ",
        //           txnIndex => 1,
        //           createdAt => "2024-03-27T23:51:14.933108Z",
        //           updatedAt => "2024-03-27T23:51:28.93706Z",
        //           txnState => "confirmed",
        //           kytStatus => "accept",
        //           $address => "79xoQgxNgKbjDrwp3Gb6t1oc1NmcgZ3PQFE7i1XCrk5x",
        //           fiatToCrypto => false,
        //         ),
        //       ),
        //     ),
        //   ),
        //
        // fetchWithdrawals
        //
        // result => array(
        //     "161" => array(
        //       name => "primary",
        //       inner => array(
        //         array(
        //           assetId => 80005,
        //           $amount => "100000000",
        //           createdAt => "2024-05-02T18:03:36.779453Z",
        //           updatedAt => "2024-05-02T18:03:37.941902Z",
        //           attemptId => 208,
        //           $address => "6khUqefutr3xA6fEUnZfRMRGwER8BBTZZFFgBPhuUyyp",
        //           kytStatus => "accept",
        //           approved => true,
        //         ),
        //       ),
        //     ),
        //   ),
        //
        // TODO Expose this object globally for the exchange so the currencies can be retrieved in O(1) time!!!
        $currenciesByNumericId = array();
        for ($i = 0; $i < $this->count_items($this->currencies); $i++) {
            $currenciesKeysArray = is_array($this->currencies) ? array_keys($this->currencies) : array();
            $targetCurrency = $this->safe_value($this->currencies, $currenciesKeysArray[$i]);
            $targetCurrencyNumericId = $this->safe_integer($targetCurrency, 'numericId');
            $currenciesByNumericId[$targetCurrencyNumericId] = $targetCurrency;
        }
        $id = $this->safe_string($transaction, 'attemptId');
        $txId = $this->safe_string($transaction, 'txnHash');
        $code = $this->safe_string($currenciesByNumericId[$this->safe_integer($transaction, 'assetId')], 'code');
        $timestamp = $this->parse8601($this->safe_string($transaction, 'createdAt'));
        $updated = $this->parse8601($this->safe_string($transaction, 'updatedAt'));
        $status = $this->parse_transaction_status($this->safe_string($transaction, 'kytStatus'));
        $address = $this->safe_string($transaction, 'address');
        $type = $this->safe_string($transaction, 'type', null);
        $assetAmount = $this->parse_to_numeric($this->safe_string($transaction, 'amount'));
        $assetNumericId = $this->parse_to_int($this->safe_string($transaction, 'assetId'));
        $currency = $currenciesByNumericId[$assetNumericId];
        $currencyPrecision = $this->safe_integer($currency, 'precision');
        $amount = $assetAmount / pow(10, $currencyPrecision);
        return array(
            'info' => $transaction,
            'id' => $id,
            'txid' => $txId,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'network' => null,
            'addressFrom' => null,
            'address' => $address,
            'addressTo' => $address,
            'tagFrom' => null,
            'tag' => null,
            'tagTo' => null,
            'type' => $type,
            'amount' => $amount,
            'currency' => $code,
            'status' => $status,
            'updated' => $updated,
            'fee' => null,
            'comment' => null,
            'internal' => null,
        );
    }

    public function parse_transaction_status($status) {
        $statuses = array(
            // what are other $statuses here?
            'WITHHOLD' => 'ok',
            'UNCONFIRMED' => 'pending',
            'CONFIRMED' => 'ok',
            'COMPLETED' => 'ok',
            'PENDING' => 'pending',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function count_with_loop($items) {
        $counter = 0;
        for ($i = 0; $i < count($items); $i++) {
            $counter += 1;
        }
        return $counter;
    }

    public function count_items($input) {
        $counter = 0;
        if (gettype($input) === 'array' && array_keys($input) === array_keys(array_keys($input))) {
            $counter = $this->count_with_loop($input);
        } elseif (gettype($input) === 'array' && $input !== null) {
            $keys = is_array($input) ? array_keys($input) : array();
            $counter = $this->count_with_loop($keys);
        } elseif (gettype($input) === 'string') {
            $counter = $this->count_with_loop($this->string_to_chars_array($input));
        }
        return $counter;
    }
}
