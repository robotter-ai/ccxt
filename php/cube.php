<?php

namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\abstract\cube as Exchange;

class cube extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'id' => 'cube',
            'name' => 'cube',
            'countries' => array(),
            'urls' => array(
                'referral' => '',
                'logo' => '', // TODO Add Cube logo URL.
                'api' => array(
                    'rest' => array(
                        'production' => array(
                            'iridium' => 'https://api.cube.exchange/ir/v0',
                            'mendelev' => 'https://api.cube.exchange/md/v0',
                            'osmium' => 'https://api.cube.exchange/os/v0',
                        ),
                        'staging' => array(
                            'iridium' => 'https://staging.cube.exchange/ir/v0',
                            'mendelev' => 'https://staging.cube.exchange/md/v0',
                            'osmium' => 'https://staging.cube.exchange/os/v0',
                        ),
                    ),
                    'ws' => array(
                        'production' => array(
                            'iridium' => 'wss://api.cube.exchange/ir',
                            'mendelev' => 'wss://api.cube.exchange/md',
                            'osmium' => 'wss://api.cube.exchange/os',
                        ),
                        'staging' => array(
                            'iridium' => 'wss://staging.cube.exchange/ir',
                            'mendelev' => 'wss://staging.cube.exchange/md',
                            'osmium' => 'wss://staging.cube.exchange/os',
                        ),
                    ),
                ),
                'www' => 'https://www.cube.exchange/',
                'doc' => 'https://cubexch.gitbook.io/cube-api',
                'fees' => 'https://www.cube.exchange/fees',
            ),
            'version' => 'v0',
            'api' => array(
                'rest' => array(
                    'iridium' => array(
                        'public' => array(
                            'get' => array(
                                '/markets' => 1,
                                '/history/klines' => 1,
                            ),
                        ),
                        'private' => array(
                            'get' => array(
                                '/users/check' => 1,
                                '/users/info' => 1,
                                '/users/subaccounts' => 1,
                                '/users/subaccount/{subaccountId}' => 1,
                                '/users/subaccount/{subaccountId}/positions' => 1,
                                '/users/subaccount/{subaccountId}/transfers' => 1,
                                '/users/subaccount/{subaccountId}/deposits' => 1,
                                '/users/subaccount/{subaccountId}/withdrawals' => 1,
                                '/users/subaccount/{subaccountId}/orders' => 1,
                                '/users/subaccount/{subaccountId}/fills' => 1,
                                '/users/fee-estimate/{market_id}' => 1,
                                '/users/address' => 1,
                                '/users/address/settings' => 1,
                            ),
                            'post' => array(
                                '/users/withdraw' => 1,
                                '/users/subaccounts' => 1,
                            ),
                            'patch' => array(
                                '/users/subaccount/{subaccountId}' => 1,
                            ),
                        ),
                    ),
                    'mendelev' => array(
                        'public' => array(
                            'get' => array(
                                '/book/{market_id}/snapshot' => 1,
                                '/parsed/book/{market_symbol}/snapshot' => 1,
                                '/book/{market_id}/recent-trades' => 1,
                                '/parsed/book/{market_symbol}/recent-trades' => 1,
                                '/tickers/snapshot' => 1,
                                '/parsed/tickers' => 1,
                            ),
                        ),
                    ),
                    'osmium' => array(
                        'private' => array(
                            'get' => array(
                                '/orders' => 1,
                                '/positions' => 1,
                            ),
                            'delete' => array(
                                '/orders' => 1,
                                '/order' => 1,
                            ),
                            'post' => array(
                                '/order' => 1,
                            ),
                            'patch' => array(
                                '/order' => 1,
                            ),
                        ),
                    ),
                ),
            ),
            'has' => array(
                'CORS' => null,
                'spot' => true,
                'margin' => false,
                'swap' => true,
                'future' => false,
                'option' => false,
                'addMargin' => false,
                'cancelAllOrders' => true,
                'cancelOrder' => true,
                'cancelOrders' => false,
                'closeAllPositions' => false,
                'closePosition' => false,
                'createDepositAddress' => false,
                'createMarketOrder' => false,
                'createOrder' => true,
                'createOrders' => false,
                'createPostOnlyOrder' => false,
                'createReduceOnlyOrder' => false,
                'createStopLimitOrder' => false,
                'createStopMarketOrder' => false,
                'createStopOrder' => false,
                'fetchAccounts' => true,
                'fetchBalance' => true,
                'fetchBorrowInterest' => false,
                'fetchBorrowRateHistory' => false,
                'fetchCanceledOrders' => false,
                'fetchClosedOrders' => 'emulated',
                'fetchCrossBorrowRate' => false,
                'fetchCrossBorrowRates' => false,
                'fetchCurrencies' => true,
                'fetchDeposit' => false,
                'fetchDepositAddress' => false,
                'fetchDepositAddresses' => false,
                'fetchDepositAddressesByNetwork' => false,
                'fetchDeposits' => true,
                'fetchDepositsWithdrawals' => false,
                'fetchFundingHistory' => false,
                'fetchFundingRate' => false,
                'fetchFundingRateHistory' => false,
                'fetchFundingRates' => false,
                'fetchIndexOHLCV' => false,
                'fetchIsolatedBorrowRate' => false,
                'fetchIsolatedBorrowRates' => false,
                'fetchLedger' => false,
                'fetchLedgerEntry' => false,
                'fetchLeverageTiers' => false,
                'fetchMarketLeverageTiers' => false,
                'fetchMarkets' => true,
                'fetchMarkOHLCV' => false,
                'fetchMyTrades' => 'emulated',
                'fetchOHLCV' => true,
                'fetchOpenInterest' => false,
                'fetchOpenInterestHistory' => false,
                'fetchOpenOrders' => true,
                'fetchOrder' => true,
                'fetchOrderBook' => true,
                'fetchOrderBooks' => false,
                'fetchOrders' => false,
                'fetchOrderTrades' => false,
                'fetchPermissions' => false,
                'fetchPosition' => false,
                'fetchPositions' => false,
                'fetchPositionsForSymbol' => false,
                'fetchPositionsRisk' => false,
                'fetchPremiumIndexOHLCV' => false,
                'fetchStatus' => true,
                'fetchTicker' => true,
                'fetchTickers' => false,
                'fetchTrades' => true,
                'fetchTradingFee' => true,
                'fetchTradingLimits' => false,
                'fetchTransactionFee' => false,
                'fetchTransactionFees' => false,
                'fetchTransactions' => false,
                'fetchTransfers' => false,
                'fetchWithdrawAddresses' => false,
                'fetchWithdrawal' => false,
                'fetchWithdrawals' => true,
                'reduceMargin' => false,
                'setLeverage' => false,
                'setMargin' => false,
                'setMarginMode' => false,
                'setPositionMode' => false,
                'signIn' => false,
                'transfer' => false,
                'withdraw' => true,
            ),
            'timeframes' => array(
                '1s' => '1s',
                '1m' => '1m',
                '15m' => '15m',
                '1h' => '1h',
                '4h' => '4h',
                '1d' => '1d',
                '0' => '1s',
                '1' => '1m',
                '2' => '15m',
                '3' => '1h',
                '4' => '4h',
                '5' => '1d',
                'S1' => '1s',
                'M1' => '1m',
                'M15' => '15m',
                'H1' => '1h',
                'H4' => '4h',
                '1y' => '1d',
            ),
            'timeout' => 10000,
            'rateLimit' => 100,
            'userAgent' => false,
            'verbose' => false,
            'markets' => null,
            'symbols' => null,
            'currencies' => null,
            'markets_by_id' => null,
            'currencies_by_id' => null,
            'apiKey' => null,
            'secret' => null,
            'password' => null,
            'uid' => '',
            'options' => array(
                'environment' => 'production',
                'subaccountId' => null,
                'networks' => array(
                    'BTC' => '1',
                    'ERC20' => '2',
                    'SPL' => '3',
                    'DOGE' => '4',
                    'TAO' => '5',
                    'LTC' => '6',
                    'tBTC' => '7',
                    'tETH' => '8',
                ),
                'impliedNetworks' => array(
                    'ETH' => array( 'ERC20' => '2' ),
                    'SOL' => array( 'SPL' => '3' ),
                ),
                'legalMoney' => array(
                    'USD' => true,
                ),
            ),
            'pro' => true,
            'fees' => array(
                'trading' => array(
                    'maker' => $this->parse_number('0.0004'),
                    'taker' => $this->parse_number('0.0008'),
                ),
            ),
            'commonCurrencies' => null,
            'precisionMode' => DECIMAL_PLACES,
            'exceptions' => array(
                'exact' => array(
                    'Must be authorized' => '\\ccxt\\AuthenticationError',
                    'Market not found' => '\\ccxt\\BadRequest',
                    'Insufficient funds' => '\\ccxt\\InsufficientFunds',
                    'Order not found' => '\\ccxt\\BadRequest',
                ),
            ),
        ));
    }

    public function generate_signature(): mixed {
        $timestamp = $this->seconds();
        $timestampBytes = $this->number_to_le($timestamp, 8);
        $secretKeyBytes = $this->base16_to_binary($this->secret);
        $message = $this->binary_concat($this->encode('cube.xyz'), $timestampBytes);
        $signature = $this->hmac($message, $secretKeyBytes, 'sha256', 'base64');
        return array( $signature, $timestamp );
    }

    public function generate_authentication_headers() {
        list($signature, $timestamp) = $this->generate_signature();
        return array(
            'x-api-key' => $this->apiKey,
            'x-api-signature' => $signature,
            'x-api-timestamp' => (string) $timestamp,
        );
    }

    public function authenticate_request(mixed $request): mixed {
        $headers = $this->safe_dict($request, 'headers', array());
        $request['headers'] = array_merge($headers, $this->generate_authentication_headers());
        return $request;
    }

    public function sign(string $path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        $environment = $this->options['environment'];
        $endpoint = null;
        $apiArray = null;
        if (gettype($api) === 'string') {
            $apiArray = explode(',', $api);
        } else {
            $apiArray = $api;
        }
        for ($i = 0; $i < count($apiArray); $i++) {
            if ($api[$i] === 'iridium') {
                $endpoint = 'iridium';
                break;
            } elseif ($api[$i] === 'mendelev') {
                $endpoint = 'mendelev';
                break;
            } elseif ($api[$i] === 'osmium') {
                $endpoint = 'osmium';
                break;
            }
        }
        $baseUrl = $this->urls['api']['rest'][$environment][$endpoint];
        $url = $baseUrl . $this->implode_params($path, $params);
        $params = $this->omit($params, $this->extract_params($path));
        $methods = array( 'GET', 'HEAD' );
        $found = false;
        for ($i = 0; $i < count($methods); $i++) {
            if ($methods[$i] === $method) {
                if ($this->count_items($params) > 0) {
                    $url .= '?' . $this->urlencode($params);
                }
                $found = true;
                break;
            }
        }
        if (!$found) {
            $body = json_encode ($params);
        }
        $found = false;
        for ($i = 0; $i < count($apiArray); $i++) {
            if ($apiArray[$i] === 'private') {
                $found = true;
                break;
            }
        }
        if ($found) {
            $request = array(
                'headers' => array(
                    'Content-Type' => 'application/json',
                    'Referer' => 'CCXT',
                ),
            );
            $request = $this->authenticate_request($request);
            $headers = $request['headers'];
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function set_sandbox_mode($enable) {
        if ($enable === true) {
            $this->options['environment'] = 'staging';
        } else {
            $this->options['environment'] = 'production';
        }
    }

    public function fetch_market_meta(mixed $symbolOrSymbols = null) {
        $symbol = null;
        $marketId = null;
        $market = null;
        $symbols = null;
        $marketIds = null;
        $markets = null;
        $this->load_markets();
        if ($symbolOrSymbols !== null) {
            if (gettype($symbolOrSymbols) === 'string') {
                $marketId = str_replace('/', '', strtoupper($symbolOrSymbols));
                $market = $this->market($marketId);
                $marketId = $market['id'];
                $symbolOrSymbols = $this->safe_symbol($marketId, $market);
                $symbol = $symbolOrSymbols;
                return array(
                    'symbol' => $symbol,
                    'marketId' => $marketId,
                    'market' => $market,
                    'symbols' => $symbols,
                    'marketIds' => $marketIds,
                    'markets' => $markets,
                );
            } elseif (gettype($symbolOrSymbols) === 'array' && array_keys($symbolOrSymbols) === array_keys(array_keys($symbolOrSymbols))) {
                $marketIds = array();
                $markets = array();
                for ($i = 0; $i < count($symbolOrSymbols); $i++) {
                    $marketId = str_replace('/', '', strtoupper($symbolOrSymbols[$i]));
                    $market = $this->market($marketId);
                    $marketId = $market['id'];
                    $symbolOrSymbols[$i] = $this->safe_symbol($marketId, $market);
                    $marketIds[] = $marketId;
                    $markets[] = $market;
                }
                $symbolOrSymbols = $this->market_symbols($symbolOrSymbols);
                $symbols = $symbolOrSymbols;
                return array(
                    'symbol' => $symbol,
                    'marketId' => $marketId,
                    'market' => $market,
                    'symbols' => $symbols,
                    'marketIds' => $marketIds,
                    'markets' => $markets,
                );
            } else {
                throw new BadSymbol($this->id . ' $symbolOrSymbols must be a string or an array of strings');
            }
        }
        return array(
            'symbol' => $symbol,
            'marketId' => $marketId,
            'market' => $market,
            'symbols' => $symbols,
            'marketIds' => $marketIds,
            'markets' => $markets,
        );
    }

    public function inject_sub_account_id($request, $params) {
        if ($this->safe_integer($params, 'subaccountId') !== null) {
            $request['subaccountId'] = $this->safe_integer($params, 'subaccountId');
        } elseif ($this->safe_integer($params, 'subAccountId') !== null) {
            $request['subaccountId'] = $this->safe_integer($params, 'subAccountId');
        } elseif ($this->safe_integer($this->options, 'subaccountId') !== null) {
            $request['subaccountId'] = $this->safe_integer($this->options, 'subaccountId');
        } elseif ($this->safe_integer($this->options, 'subAccountId') !== null) {
            $request['subaccountId'] = $this->safe_integer($this->options, 'subAccountId');
        }
    }

    public function fetch_currencies($params = array ()) {
        /**
         * fetches all available currencies on an exchange
         * @see https://cubexch.gitbook.io/cube-api/rest-iridium-api#markets
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} an associative dictionary of currencies
         */
        $response = $this->restIridiumPublicGetMarkets ($params);
        // {
        //     "result" => {
        //         "assets" => array(
        //             array(
        //                 "assetId" => 1,
        //                 "symbol" => "BTC",
        //                 "decimals" => 8,
        //                 "displayDecimals" => 5,
        //                 "settles" => true,
        //                 "assetType" => "Crypto",
        //                 "sourceId" => 1,
        //                 "metadata" => array(
        //                     "dustAmount" => 3000
        //                 ),
        //                 "status" => 1
        //             ),
        //             ...
        //         ),
        //         ...
        //     }
        // }
        $assets = $this->safe_list($this->safe_dict($response, 'result'), 'assets');
        return $this->parse_currencies($assets);
    }

    public function parse_currencies(array $assets): array {
        $result = array();
        for ($i = 0; $i < count($assets); $i++) {
            $rawCurrency = $assets[$i];
            $id = strtolower($this->safe_string($rawCurrency, 'symbol'));
            $code = strtoupper($id);
            $name = $this->safe_string($this->safe_dict($rawCurrency, 'metadata'), 'currencyName');
            $networkId = $this->safe_string($rawCurrency, 'sourceId');
            $networks = array();
            $networks[$networkId] = $networkId;
            $currency = $this->safe_currency_structure(array(
                'info' => $rawCurrency,
                'id' => $id,
                'numericId' => $this->safe_integer($rawCurrency, 'assetId'),
                'code' => $code,
                'precision' => $this->safe_integer($rawCurrency, 'decimals'),
                'type' => $this->safe_string_lower($rawCurrency, 'assetType'),
                'name' => $name,
                'active' => $this->safe_integer($rawCurrency, 'status') === 1,
                'deposit' => false,
                'withdraw' => true,
                'fee' => null, // TODO => What kind of fee is this? !!!
                'fees' => array(),
                'networks' => $networks,
                'limits' => array(
                    'amount' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'withdraw' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'deposit' => array(
                        'min' => null,
                        'max' => null,
                    ),
                ),
            ));
            $result[$code] = $currency;
        }
        return $result;
    }

    public function fetch_markets($params = array ()): array {
        /**
         * retrieves data on all markets for cube
         * @see https://cubexch.gitbook.io/cube-api/rest-iridium-api#markets
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array[]} an array of objects representing market data
         */
        $response = $this->restIridiumPublicGetMarkets ($params);
        // {
        //     "result" => {
        //         "assets" => array(
        //             array(
        //                 "assetId" => 1,
        //                 "symbol" => "BTC",
        //                 "decimals" => 8,
        //                 "displayDecimals" => 5,
        //                 "settles" => true,
        //                 "assetType" => "Crypto",
        //                 "sourceId" => 1,
        //                 "metadata" => array(
        //                     "dustAmount" => 3000
        //                 ),
        //                 "status" => 1
        //             ),
        //             ...
        //         ),
        //         "markets" => array(
        //             array(
        //                 "marketId" => 100004,
        //                 "symbol" => "BTCUSDC",
        //                 "baseAssetId" => 1,
        //                 "baseLotSize" => "1000",
        //                 "quoteAssetId" => 7,
        //                 "quoteLotSize" => "1",
        //                 "priceDisplayDecimals" => 2,
        //                 "protectionPriceLevels" => 3000,
        //                 "priceBandBidPct" => 25,
        //                 "priceBandAskPct" => 400,
        //                 "priceTickSize" => "0.1",
        //                 "quantityTickSize" => "0.00001",
        //                 "status" => 1,
        //                 "feeTableId" => 2
        //             ),
        //             ...
        //         ),
        //         "feeTables" => array(
        //             {
        //                 "feeTableId" => 1,
        //                 "feeTiers" => array(
        //                     array(
        //                         "priority" => 0,
        //                         "makerFeeRatio" => 0.0,
        //                         "takerFeeRatio" => 0.0
        //                     }
        //                 )
        //             ),
        //             {
        //                 "feeTableId" => 2,
        //                 "feeTiers" => array(
        //                     {
        //                         "priority" => 0,
        //                         "makerFeeRatio" => 0.0004,
        //                         "takerFeeRatio" => 0.0008
        //                     }
        //                 )
        //             }
        //         )
        //     }
        // }
        $rawMarkets = $this->safe_list($this->safe_dict($response, 'result'), 'markets');
        $rawAssets = $this->safe_list($this->safe_dict($response, 'result'), 'assets');
        $this->currencies = $this->parse_currencies($rawAssets);
        return $this->parse_markets($rawMarkets);
    }

    public function parse_markets(array $markets): array {
        $result = array();
        for ($i = 0; $i < count($markets); $i++) {
            $market = $this->parse_market($markets[$i]);
            $result[] = $market;
        }
        return $result;
    }

    public function parse_market(array $market): array {
        $id = strtoupper($this->safe_string($market, 'symbol'));
        $currenciesByNumericId = array();
        for ($i = 0; $i < $this->count_items($this->currencies); $i++) {
            $currenciesKeysArray = is_array($this->currencies) ? array_keys($this->currencies) : array();
            $targetCurrency = $this->safe_value($this->currencies, $currenciesKeysArray[$i]);
            $targetCurrencyNumericId = $this->safe_integer($targetCurrency, 'numericId');
            $currenciesByNumericId[$targetCurrencyNumericId] = $targetCurrency;
        }
        $baseAsset = $currenciesByNumericId[$this->safe_integer($market, 'baseAssetId')];
        $quoteAsset = $currenciesByNumericId[$this->safe_integer($market, 'quoteAssetId')];
        $baseSymbol = $this->safe_string($this->safe_dict($baseAsset, 'info'), 'symbol');
        $quoteSymbol = $this->safe_string($this->safe_dict($quoteAsset, 'info'), 'symbol');
        $marketSymbol = $baseSymbol . $quoteSymbol;
        return $this->safe_market_structure(array(
            'id' => $id,
            'lowercaseId' => strtolower($id),
            'symbol' => $marketSymbol,
            'base' => $this->safe_string($baseAsset, 'code'),
            'quote' => $this->safe_string($quoteAsset, 'code'),
            'settle' => null,
            'baseId' => $this->safe_string($baseAsset, 'id'),
            'quoteId' => $this->safe_string($quoteAsset, 'id'),
            'settleId' => null,
            'type' => 'spot',
            'spot' => true,
            'margin' => false,
            'swap' => false,
            'future' => false,
            'option' => false,
            'active' => $this->safe_integer($market, 'status') === 1,
            'contract' => false,
            'linear' => null,
            'inverse' => null,
            'contractSize' => null,
            'taker' => $this->safe_number($this->safe_dict($this->fees, 'trading'), 'taker'),
            'maker' => $this->safe_number($this->safe_dict($this->fees, 'trading'), 'maker'),
            'expiry' => null,
            'expiryDatetime' => null,
            'strike' => null,
            'optionType' => null,
            'precision' => array(
                'amount' => $this->count_decimal_places($this->safe_string($market, 'quantityTickSize')),
                'price' => $this->count_decimal_places($this->safe_string($market, 'priceTickSize')),
                'cost' => null,
                'base' => null,
                'quote' => null,
            ),
            'limits' => array(
                'leverage' => array(
                    'min' => null,
                    'max' => null,
                ),
                'amount' => array(
                    'min' => null,
                    'max' => null,
                ),
                'price' => array(
                    'min' => null,
                    'max' => null,
                ),
                'cost' => array(
                    'min' => null,
                    'max' => null,
                ),
            ),
            'created' => null,
            'info' => $market,
        ));
    }

    public function fetch_order_book(string $symbol, ?int $limit = null, $params = array ()): array {
        /**
         * fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
         * @see https://cubexch.gitbook.io/cube-api/rest-mendelev-api#book-market_id-snapshot
         * @see https://cubexch.gitbook.io/cube-api/rest-mendelev-api#parsed-book-market_symbol-snapshot
         * @param {string} $symbol unified $symbol of the market to fetch the order book for
         * @param {int} [$limit] the maximum amount of order book entries to return
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} A dictionary of ~@link https://docs.ccxt.com/#/?id=order-book-structure order book structures~ indexed by $market symbols
         */
        $meta = $this->fetch_market_meta($symbol);
        $symbol = $this->safe_string($meta, 'symbol');
        $request = array( 'market_symbol' => $symbol );
        $response = $this->restMendelevPublicGetParsedBookMarketSymbolSnapshot (array_merge($request, $params));
        //
        // {
        //   "result":{
        //       "ticker_id":"BTCUSDC",
        //       "timestamp":1711544655331,
        //       "bids":array(
        //           array(
        //               70635.6,
        //               0.01
        //           )
        //       ),
        //       "asks":array(
        //           array(
        //               70661.8,
        //               0.1421
        //           )
        //       )
        //   }
        // }
        //
        $rawBids = $this->safe_list($this->safe_dict($response, 'result'), 'bids', array());
        $rawAsks = $this->safe_list($this->safe_dict($response, 'result'), 'asks', array());
        $bids = array();
        for ($i = 0; $i < $this->count_items($rawBids); $i++) {
            if (!($this->parse_to_numeric($rawBids[$i][0]) <= 0 || $this->parse_to_numeric($rawBids[$i][1]) <= 0)) {
                $bids[] = $rawBids[$i];
            }
        }
        $asks = array();
        for ($i = 0; $i < $this->count_items($rawAsks); $i++) {
            if (!($this->parse_to_numeric($rawAsks[$i][0]) <= 0 || $this->parse_to_numeric($rawAsks[$i][1]) <= 0)) {
                $asks[] = $rawAsks[$i];
            }
        }
        $rawOrderbook = array(
            'bids' => $bids,
            'asks' => $asks,
        );
        $timestamp = $this->safe_integer($this->safe_dict($response, 'result'), 'timestamp'); // Don't use $this->safe_timestamp()
        return $this->parse_order_book($rawOrderbook, $symbol, $timestamp, 'bids', 'asks');
    }

    public function parse_bids_asks($bidasks, int|string $priceKey = 0, int|string $amountKey = 1, int|string $countOrIdKey = 2): array {
        return $bidasks;
    }

    public function fetch_ticker(string $symbol, $params = array ()): array {
        /**
         * fetches a price $ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
         * @see https://cubexch.gitbook.io/cube-api/rest-mendelev-api#parsed-$tickers
         * @param {string} $symbol unified $symbol of the market to fetch the $ticker for
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} a ~@link https://docs.ccxt.com/#/?id=$ticker-structure $ticker structure~
         */
        $meta = $this->fetch_market_meta($symbol);
        $symbol = $this->safe_string($meta, 'symbol');
        $tickers = $this->fetch_tickers(array( $symbol ), $params);
        $ticker = $this->safe_value($tickers, $symbol, null);
        if ($ticker === null) {
            throw new BadSymbol($this->id . ' fetchTicker() $symbol ' . $symbol . ' not found');
        }
        return $ticker;
    }

    public function parse_ticker(array $ticker, ?array $market = null): array {
        //
        //       {
        //         ticker_id => "JTOUSDC",
        //         base_currency => "JTO",
        //         quote_currency => "USDC",
        //         $timestamp => 1713217334960,
        //         last_price => 2.6624,
        //         base_volume => 337.12,
        //         quote_volume => 961.614166,
        //         bid => 2.6627,
        //         ask => 2.6715,
        //         high => 3.0515,
        //         low => 2.6272,
        //         open => 2.8051,
        //       }
        //
        $timestamp = $this->safe_integer($ticker, 'timestamp');
        return $this->safe_ticker(array(
            'symbol' => $this->safe_string($market, 'symbol'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'high' => $this->safe_number($ticker, 'high'),
            'low' => $this->safe_number($ticker, 'low'),
            'bid' => $this->safe_number($ticker, 'bid'),
            'bidVolume' => $this->safe_number($ticker, 'base_volume'),
            'ask' => $this->safe_number($ticker, 'ask'),
            'askVolume' => $this->safe_number($ticker, 'quote_volume'),
            'vwap' => null,
            'open' => $this->safe_number($ticker, 'open'),
            'close' => null,
            'last' => $this->safe_number($ticker, 'last_price'),
            'previousClose' => null,
            'change' => null,
            'percentage' => null,
            'average' => null,
            'baseVolume' => $this->safe_number($ticker, 'base_volume'),
            'quoteVolume' => $this->safe_number($ticker, 'quote_volume'),
            'info' => $ticker,
        ), $market);
    }

    public function fetch_tickers(?array $symbols = null, $params = array ()): array {
        /**
         * fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each $market
         * @see https://cubexch.gitbook.io/cube-api/rest-mendelev-api#parsed-tickers
         * @param {string[]|null} $symbols unified $symbols of the markets to fetch the $ticker for, all $market tickers are returned if not assigned
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} a dictionary of ~@link https://docs.ccxt.com/#/?id=$ticker-structure $ticker structures~
         */
        $meta = $this->fetch_market_meta($symbols);
        $symbols = $this->safe_list($meta, 'symbols');
        $response = $this->restMendelevPublicGetParsedTickers ($params);
        //
        //  {
        //     $result => array(
        //       array(
        //     ticker_id => "JTOUSDC",
        //     base_currency => "JTO",
        //     quote_currency => "USDC",
        //     timestamp => 1713216571697,
        //     last_price => 2.6731,
        //     base_volume => 333.66,
        //     quote_volume => 953.635304,
        //     bid => 2.6653,
        //     ask => 2.6761,
        //     high => 3.0515,
        //     low => 2.6272,
        //     open => 2.8231,
        //      ),
        //    ),
        //  }
        //
        $rawTickers = $this->safe_list($response, 'result', array());
        $result = array();
        for ($i = 0; $i < count($rawTickers); $i++) {
            $rawTicker = $rawTickers[$i];
            $marketId = str_replace('/', '', strtoupper($this->market_id($this->safe_string($rawTicker, 'ticker_id'))));
            $market = $this->market($marketId);
            $symbol = $this->safe_string($market, 'symbol');
            $ticker = $this->parse_ticker($rawTicker, $market);
            $result[$symbol] = $ticker;
        }
        return $this->filter_by_array_tickers($result, 'symbol', $symbols);
    }

    public function fetch_ohlcv(string $symbol, $timeframe = '1m', ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * fetches historical candlestick $data containing the open, high, low, and close price, and the volume of a $market
         * @see https://cubexch.gitbook.io/cube-api/rest-mendelev-api#parsed-tickers
         * @param {string} $symbol unified $symbol of the $market to fetch OHLCV $data for
         * @param {string} $timeframe the length of time each candle represents
         * @param {int} [$since] timestamp in ms of the earliest candle to fetch
         * @param {int} [$limit] the maximum amount of candles to fetch
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {int[][]} A list of candles ordered, open, high, low, close, volume
         */
        $meta = $this->fetch_market_meta($symbol);
        $symbol = $this->safe_string($meta, 'symbol');
        $market = $this->safe_dict($meta, 'market');
        $marketNumericId = $this->safe_integer($this->safe_dict($market, 'info'), 'marketId');
        $selectedTimeframe = $this->timeframes[$timeframe];
        $request = array(
            'interval' => $selectedTimeframe,
        );
        if ($params['marketId'] !== null) {
            $request['marketId'] = $params['marketId'];
        } else {
            $request['marketId'] = $marketNumericId;
        }
        if ($since !== null) {
            $request['start_time'] = $since; // The unix nanosecond timestamp that this kline covers.
        }
        $response = $this->restIridiumPublicGetHistoryKlines (array_merge($request, $params));
        $data = $this->safe_value($response, 'result', array());
        //
        //  {
        //    "result" => array(
        //      array(
        //        1715280300,
        //        14736,
        //        14736,
        //        14736,
        //        14736,
        //        "7299"
        //      ),
        //      array(
        //        1715279400,
        //        14734,
        //        14768,
        //        14720,
        //        14720,
        //        "14242"
        //      )
        //    )
        //  }
        //
        return $this->parse_ohlcvs($data, $market, (string) $selectedTimeframe, $since, $limit);
    }

    public function parse_ohlcv($ohlcv, ?array $market = null): array {
        // Cube KLine format
        // [
        //     1715278500,  // start_time           |   $ohlcv[0]
        //     14695,       // Kline open price.    |   $ohlcv[1]
        //     14695,       // Kline close price.   |   $ohlcv[2]
        //     14695,       // Kline high price.    |   $ohlcv[3]
        //     14695,       // Kline low price.     |   $ohlcv[4]
        //     "5784"       // volume_hi            |   $ohlcv[5]
        // ]
        //
        // CCXT KLine format
        // [
        //     1504541580000, // UTC timestamp in milliseconds, integer |   $ohlcv[0]
        //     4235.4,        // (O)pen price, float                    |   $ohlcv[1]
        //     4240.6,        // (H)ighest price, float                 |   $ohlcv[3]
        //     4230.0,        // (L)owest price, float                  |   $ohlcv[4]
        //     4230.7,        // (C)losing price, float                 |   $ohlcv[2]
        //     37.72941911    // (V)olume, float                        |   $ohlcv[5]
        // ],
        return [
            $ohlcv[0],
            $ohlcv[1],
            $ohlcv[3],
            $ohlcv[4],
            $ohlcv[2],
            $this->parse_to_numeric($ohlcv[5]),
        ];
    }

    public function fetch_balance($params = array ()): array {
        /**
         * query for balance and get the amount of funds available for trading or funds locked in orders
         * @see https://cubexch.gitbook.io/cube-api/rest-iridium-api#users-positions
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} a {@link https://github.com/ccxt/ccxt/wiki/Manual#order-structure balance structure}
         */
        $this->fetch_market_meta();
        $request = array();
        $this->inject_sub_account_id($request, $params);
        $response = $this->restIridiumPrivateGetUsersSubaccountSubaccountIdPositions (array_merge($request, $params));
        $subaccountId = $this->safe_string($this->options, 'subaccountId');
        $allOrders = $this->fetch_raw_orders();
        $result = $this->safe_list($this->safe_dict($this->safe_dict($response, 'result'), $subaccountId), 'inner');
        return $this->parse_balance(array( 'result' => $result, 'allOrders' => $allOrders ));
    }

    public function parse_balance(mixed $response): array {
        $result = $this->safe_dict($response, 'result');
        $allOrders = $this->safe_dict($response, 'allOrders');
        $openOrders = array();
        $filledUnsettledOrders = array();
        $allMarketsByNumericId = array();
        for ($i = 0; $i < $this->count_items($this->markets_by_id); $i++) {
            $marketArrayItem = is_array($this->markets_by_id) ? array_values($this->markets_by_id) : array()[$i];
            $market = $marketArrayItem[0];
            $marketInfo = $this->safe_dict($market, 'info');
            $marketNumericId = $this->safe_string($marketInfo, 'marketId');
            $allMarketsByNumericId[$marketNumericId] = $market;
        }
        $free = array();
        $used = array();
        $total = array();
        $currenciesByNumericId = array();
        for ($i = 0; $i < $this->count_items($this->currencies); $i++) {
            $currenciesKeysArray = is_array($this->currencies) ? array_keys($this->currencies) : array();
            $targetCurrency = $this->safe_value($this->currencies, $currenciesKeysArray[$i]);
            $targetCurrencyNumericId = $this->safe_integer($targetCurrency, 'numericId');
            $currenciesByNumericId[$targetCurrencyNumericId] = $targetCurrency;
        }
        for ($i = 0; $i < $this->count_items($result); $i++) {
            $asset = $result[$i];
            $assetAmount = intval($this->safe_string($asset, 'amount'));
            if ($assetAmount > 0) {
                $assetNumericId = $this->parse_to_int($this->safe_string($asset, 'assetId'));
                $currency = $currenciesByNumericId[$assetNumericId];
                $currencyPrecision = $this->safe_integer($currency, 'precision');
                $assetSymbol = $this->safe_string($currency, 'code');
                $total[$assetSymbol] = $assetAmount / pow(10, $currencyPrecision);
                $used[$assetSymbol] = 0; // To prevent the 'parser' from adding 'null' when there are no orders holding an $asset->
                $free[$assetSymbol] = 0; // To prevent the 'parser' from adding 'null' when there are no orders holding an $asset->
            }
        }
        for ($i = 0; $i < $this->count_items($allOrders); $i++) {
            $order = $allOrders[$i];
            $orderStatus = $this->safe_string($order, 'status');
            if ($orderStatus === 'open') {
                $openOrders[] = $order;
            }
            if ($orderStatus === 'filled') {
                $isSettled = $this->safe_string($order, 'settled');
                if (!$isSettled) {
                    $filledUnsettledOrders[] = $order;
                }
            }
        }
        for ($i = 0; $i < $this->count_items($openOrders); $i++) {
            $order = $openOrders[$i];
            $orderMarketId = $this->safe_string($order, 'marketId');
            $orderMarket = $this->safe_dict($allMarketsByNumericId, $orderMarketId);
            $orderSide = $this->safe_string($order, 'side');
            $orderBaseToken = $this->safe_string($orderMarket, 'base');
            $orderQuoteToken = $this->safe_string($orderMarket, 'quote');
            $orderAmount = $this->safe_integer($order, 'qty');
            $orderPrice = $this->safe_integer($order, 'price');
            $targetToken = '';
            $lotSize = 0;
            if ($orderSide === 'Ask') {
                $targetToken = $orderBaseToken;
                $lotSize = $this->safe_integer($this->safe_dict($orderMarket, 'info'), 'baseLotSize');
            } elseif ($orderSide === 'Bid') {
                $targetToken = $orderQuoteToken;
                $lotSize = $this->safe_integer($this->safe_dict($orderMarket, 'info'), 'quoteLotSize');
            }
            $targetCurrency = $this->currency($targetToken);
            $targetCurrencyPrecision = $this->safe_integer($targetCurrency, 'precision');
            $orderLockedAmount = 0;
            if ($orderSide === 'Ask') {
                $orderLockedAmount = $orderAmount * $lotSize / pow(10, $targetCurrencyPrecision);
            } elseif ($orderSide === 'Bid') {
                $orderLockedAmount = $orderAmount * $orderPrice * $lotSize / pow(10, $targetCurrencyPrecision);
            }
            $used[$targetToken] .= $orderLockedAmount;
            $free[$targetToken] = $total[$targetToken] - $used[$targetToken];
        }
        for ($i = 0; $i < $this->count_items($total); $i++) { // For when an $asset does not have any values locked in orders.
            $targetToken = is_array($total) ? array_keys($total) : array()[$i];
            if ($this->safe_value($free, $targetToken) === 0) {
                $targetTokenTotalAmount = $this->safe_value($total, $targetToken);
                $free[$targetToken] = $targetTokenTotalAmount;
            }
        }
        $timestamp = $this->milliseconds();
        $balanceResult = array(
            'info' => array(
                'balances' => $result,
                'openOrders' => $openOrders,
                'filledUnsettledOrders' => $filledUnsettledOrders,
            ),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'free' => $free,
            'used' => $used,
            'total' => $total,
        );
        for ($i = 0; $i < $this->count_items($total); $i++) {
            $assetSymbol = is_array($total) ? array_keys($total) : array()[$i];
            $assetBalances = array(
                'free' => $this->safe_number($free, $assetSymbol),
                'used' => $this->safe_number($used, $assetSymbol),
                'total' => $this->safe_number($total, $assetSymbol),
            );
            $balanceResult[$assetSymbol] = $assetBalances;
        }
        return $this->safe_balance($balanceResult);
    }

    public function create_order(string $symbol, string $type, string $side, float $amount, ?float $price = null, $params = array ()): array {
        /**
         * create a trade $order
         * @see https://cubexch.gitbook.io/cube-api/rest-osmium-api#$order
         * @param {string} $symbol unified $symbol of the $market to create an $order in
         * @param {string} $type 'market' or 'limit' or 'STOP_LOSS' or 'STOP_LOSS_LIMIT' or 'TAKE_PROFIT' or 'TAKE_PROFIT_LIMIT' or 'STOP'
         * @param {string} $side 'buy' or 'sell'
         * @param {float} $amount how much of you want to trade in units of the base currency
         * @param {float} [$price] the $price that the $order is to be fullfilled, in units of the quote currency, ignored in $market orders
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} an ~@link https://docs.ccxt.com/#/?id=$order-structure $order structure~
         */
        $meta = $this->fetch_market_meta($symbol);
        $symbol = $this->safe_string($meta, 'symbol');
        $marketId = $this->safe_string($meta, 'marketId');
        $market = $this->safe_dict($meta, 'market');
        $rawMarketId = $this->safe_integer($this->safe_dict($market, 'info'), 'marketId');
        $quantityTickSize = $this->safe_number($this->safe_dict($market, 'info'), 'quantityTickSize');
        $exchangeAmount = $this->parse_to_int($amount * 1 / $quantityTickSize);
        $exchangeOrderType = null;
        if ($type === 'limit') {
            $exchangeOrderType = 0;
        } elseif ($type === 'market') {
            $exchangeOrderType = 1;
        } elseif ($type === 'MARKET_WITH_PROTECTION') {
            $exchangeOrderType = 2;
        } else {
            throw new InvalidOrder('OrderType was not recognized => ' . $type);
        }
        $exchangeOrderSide = null;
        if ($side === 'buy') {
            $exchangeOrderSide = 0;
        } elseif ($side === 'sell') {
            $exchangeOrderSide = 1;
        } else {
            throw new InvalidOrder('OrderSide was not recognized => ' . $side);
        }
        $timestamp = $this->milliseconds();
        $clientOrderIdFromParams = $this->safe_integer($params, 'clientOrderId');
        $clientOrderId = null;
        if ($clientOrderIdFromParams === null) {
            $clientOrderId = $timestamp;
        } else {
            $clientOrderId = $clientOrderIdFromParams;
        }
        $request = array(
            'clientOrderId' => $clientOrderId,
            'requestId' => $this->safe_integer($params, 'requestId', 1),
            'marketId' => $rawMarketId,
            'quantity' => $exchangeAmount,
            'side' => $exchangeOrderSide,
            'timeInForce' => $this->safe_integer($params, 'timeInForce', 1),
            'orderType' => $exchangeOrderType,
            'selfTradePrevention' => $this->safe_integer($params, 'selfTradePrevention', 0),
            'postOnly' => $this->safe_integer($params, 'postOnly', 0),
            'cancelOnDisconnect' => $this->safe_bool($params, 'cancelOnDisconnect', false),
        );
        $priceTickSize = $this->safe_number($this->safe_dict($market, 'info'), 'priceTickSize');
        if ($price !== null) {
            $request['price'] = $this->parse_to_int($price * 1 / $priceTickSize);
        }
        $this->inject_sub_account_id($request, $params);
        $response = $this->restOsmiumPrivatePostOrder (array_merge($request, $params));
        $order = $this->safe_dict($this->safe_dict($response, 'result'), 'Ack');
        if ($order === null) {
            $order = $this->safe_dict($this->safe_dict($response, 'result'), 'Rej');
        }
        $exchangeOrderId = $this->safe_string($order, 'exchangeOrderId');
        $fetchedOrder = $this->fetch_raw_order($exchangeOrderId, $marketId);
        $orderStatus = null;
        if ($fetchedOrder !== null && $this->safe_string($fetchedOrder, 'exchangeOrderId') !== null) {
            $orderStatus = 'open';
        }
        if ($fetchedOrder === null && $this->safe_dict($this->safe_dict($response, 'result'), 'Ack') !== null) {
            $orderStatus = 'filled';
        }
        if ($fetchedOrder === null && $this->safe_dict($this->safe_dict($response, 'result'), 'Rej') !== null) {
            $orderStatus = 'rejected';
        }
        return $this->parse_order(
            array(
                'order' => $order,
                'fetchedOrder' => $fetchedOrder,
                'orderStatus' => $orderStatus,
                'transactionType' => 'creation',
            ),
            $market
        );
    }

    public function cancel_order(string $id, ?string $symbol = null, $params = array ()) {
        /**
         * cancels an open order
         * @see https://cubexch.gitbook.io/cube-api/rest-osmium-api#order-1
         * @param {string} $id order $id
         * @param {string} $symbol unified $symbol of the $market the order was made in
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} An ~@link https://docs.ccxt.com/#/?$id=order-structure order structure~
         */
        $meta = $this->fetch_market_meta($symbol);
        $symbol = $this->safe_string($meta, 'symbol');
        $marketId = $this->safe_string($meta, 'marketId');
        $market = $this->safe_dict($meta, 'market');
        $rawMarketId = $this->safe_integer($this->safe_dict($market, 'info'), 'marketId');
        $fetchedOrder = $this->fetch_raw_order($id, $marketId);
        if ($fetchedOrder === null) {
            $fetchedOrder = array();
        }
        $clientOrderId = $this->safe_integer($fetchedOrder, 'clientOrderId');
        $request = array(
            'clientOrderId' => $clientOrderId,
            'requestId' => $this->safe_integer($params, 'requestId', 1),
            'marketId' => $rawMarketId,
        );
        $this->inject_sub_account_id($request, $params);
        $response = $this->restOsmiumPrivateDeleteOrder (array_merge($request, $params));
        return $this->parse_order(
            array(
                'cancellationResponse' => $response,
                'fetchedOrder' => $fetchedOrder,
                'transactionType' => 'cancellation',
            ),
            $market
        );
    }

    public function cancel_all_orders(?string $symbol = null, $params = array ()) {
        /**
         * cancel all open orders
         * @see https://cubexch.gitbook.io/cube-api/rest-osmium-api#orders-1
         * @param {string} $symbol cube cancelAllOrders cannot setting $symbol, it will cancel all open orders
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
         */
        $meta = $this->fetch_market_meta($symbol);
        $symbol = $this->safe_string($meta, 'symbol');
        $market = $this->safe_dict($meta, 'market');
        $rawMarkeId = $this->safe_integer($this->safe_dict($market, 'info'), 'marketId');
        $request = array(
            'marketId' => $rawMarkeId,
            'requestId' => $this->safe_integer($params, 'requestId', 1),
            'side' => $this->safe_integer($params, 'side', null),
        );
        $this->inject_sub_account_id($request, $params);
        $response = $this->restOsmiumPrivateDeleteOrders (array_merge($request, $params));
        return array(
            'info' => $this->safe_dict($response, 'result'),
            'market' => $market,
        );
    }

    public function fetch_order(string $id, ?string $symbol = null, $params = array ()): array {
        /**
         * fetches information on an $order made by the user
         * @see https://cubexch.gitbook.io/cube-api/rest-osmium-api#orders
         * @param {string} $symbol unified $symbol of the $market the $order was made in
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} An ~@link https://docs.ccxt.com/#/?$id=$order-structure $order structure~
         */
        $meta = $this->fetch_market_meta($symbol);
        $symbol = $this->safe_string($meta, 'symbol');
        $market = $this->safe_dict($meta, 'market');
        $order = $this->fetch_raw_order($id, $symbol, $params);
        //
        //  {
        //      "result" => {
        //          "orders" => array(
        //              array(
        //                  "clientOrderId" => 1713422528124,
        //                  "exchangeOrderId" => 1295024967,
        //                  "marketId" => 100006,
        //                  "price" => 11000,
        //                  "orderQuantity" => 1,
        //                  "side" => 0,
        //                  "timeInForce" => 1,
        //                  "orderType" => 0,
        //                  "remainingQuantity" => 1,
        //                  "restTime" => 1713422528222471490,
        //                  "subaccountId" => 38393,
        //                  "cumulativeQuantity" => 0,
        //                  "cancelOnDisconnect" => false
        //              ),
        //              ...
        //          )
        //      }
        //  }
        //
        return $this->parse_order(
            array(
                'fetchedOrder' => $order,
                'transactionType' => 'fetching',
            ),
            $market
        );
    }

    public function fetch_raw_order(string $id, $symbol = null, $params = array ()) {
        /**
         * fetches information on an $order made by the user
         * @see https://cubexch.gitbook.io/cube-api/rest-osmium-api#orders
         * @param {string} $symbol unified $symbol of the market the $order was made in
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} An ~@link https://docs.ccxt.com/#/?$id=$order-structure $order structure~
         */
        $meta = $this->fetch_market_meta($symbol);
        $symbol = $this->safe_string($meta, 'symbol');
        $request = array();
        $this->inject_sub_account_id($request, $params);
        $rawResponse = $this->restOsmiumPrivateGetOrders (array_merge($request, $params));
        //
        // {
        //    "result" => {
        //        "orders" => array(
        //            array(
        //                "clientOrderId" => 1713422528124,
        //                "exchangeOrderId" => 1295024967,
        //                "marketId" => 100006,
        //                "price" => 11000,
        //                "orderQuantity" => 1,
        //                "side" => 0,
        //                "timeInForce" => 1,
        //                "orderType" => 0,
        //                "remainingQuantity" => 1,
        //                "restTime" => 1713422528222471490,
        //                "subaccountId" => 38393,
        //                "cumulativeQuantity" => 0,
        //                "cancelOnDisconnect" => false
        //            ),
        //            ...
        //        )
        //    }
        // }
        //
        $result = $this->safe_list($this->safe_dict($rawResponse, 'result'), 'orders');
        $order = null;
        for ($i = 0; $i < $this->count_items($result); $i++) {
            $clientOrderId = $this->safe_string($result[$i], 'clientOrderId');
            $exchangeOrderId = $this->safe_string($result[$i], 'exchangeOrderId');
            if ($id === $clientOrderId || $id === $exchangeOrderId) {
                $order = $result[$i];
                break;
            }
        }
        return $order;
    }

    public function fetch_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * fetch all unfilled currently open orders
         * @param {string} $symbol unified $market $symbol of the $market orders were made in
         * @param {int} [$since] the earliest time in ms to fetch orders for
         * @param {int} [$limit] the maximum number of order structures to retrieve
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {Order[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
         */
        $meta = $this->fetch_market_meta($symbol);
        $market = $this->safe_market($this->safe_string($meta, 'marketId'), $this->safe_dict($meta, 'market'), '/');
        $rawOrders = $this->fetch_raw_orders();
        return $this->parse_orders($rawOrders, $market, $since, $limit);
    }

    public function parse_orders(array $orders, ?array $market = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        //
        // the value of $orders is either a dict or a list
        //
        // dict
        //
        //     {
        //         'id1' => array( ... ),
        //         'id2' => array( ... ),
        //         'id3' => array( ... ),
        //         ...
        //     }
        //
        // list
        //
        //     array(
        //         array( 'id' => 'id1', ... ),
        //         array( 'id' => 'id2', ... ),
        //         array( 'id' => 'id3', ... ),
        //         ...
        //     )
        //
        $results = array();
        if (gettype($orders) === 'array' && array_keys($orders) === array_keys(array_keys($orders))) {
            for ($i = 0; $i < count($orders); $i++) {
                $order = array_merge($this->parse_order(array( 'fetchedOrder' => $orders[$i], 'transactionType' => 'fetching_all' ), $market), $params);
                $results[] = $order;
            }
        } else {
            $ids = is_array($orders) ? array_keys($orders) : array();
            for ($i = 0; $i < count($ids); $i++) {
                $id = $ids[$i];
                $order = array_merge($this->parse_order(array( 'fetchedOrder' => $orders[$id], 'transactionType' => 'fetching_all' ), $market), $params);
                $results[] = $order;
            }
        }
        $results = $this->sort_by($results, 'timestamp');
        $symbol = null;
        if ($market !== null) {
            $symbol = $market['symbol'];
        }
        return $this->filter_by_symbol_since_limit($results, $symbol, $since, $limit);
    }

    public function parse_order($order, ?array $market = null) {
        $transactionType = $this->safe_string($order, 'transactionType');
        $fetchedOrder = $this->safe_dict($order, 'fetchedOrder');
        $orderStatus = null;
        if ($transactionType === 'creation') {
            $orderStatus = $this->safe_string($order, 'orderStatus');
            if ($orderStatus === 'rejected') {
                return $this->safe_order(array(
                    'status' => $orderStatus,
                ));
            }
            if ($orderStatus === 'filled') {
                $fetchedOrder = $this->safe_dict($order, 'order');
            }
        } elseif ($transactionType === 'cancellation') {
            $orderStatus = 'canceled';
        } elseif ($transactionType === 'fetching') {
            $orderStatus = 'open'; // If the $order is fetched, it is open
        } elseif ($transactionType === 'fetching_all') {
            $orderStatus = $this->safe_string($fetchedOrder, 'status'); // The $order status is present in the $order body when fetching the endpoint of all orders
        }
        if ($fetchedOrder !== null) {
            $exchangeOrderId = $this->safe_string($fetchedOrder, 'exchangeOrderId');
            $clientOrderId = $this->safe_string($fetchedOrder, 'clientOrderId');
            $timestampInNanoseconds = null;
            $timestampInNanoseconds = $this->safe_integer($fetchedOrder, 'restTime');
            if ($timestampInNanoseconds === null) {
                $timestampInNanoseconds = $this->safe_integer($fetchedOrder, 'transactTime');
            }
            if ($timestampInNanoseconds === null) {
                $timestampInNanoseconds = $this->safe_integer($fetchedOrder, 'createdAt');
            }
            if ($timestampInNanoseconds === null) {
                $timestampInNanoseconds = $this->safe_integer($fetchedOrder, 'filledAt');
            }
            if ($timestampInNanoseconds === null) {
                $timestampInNanoseconds = $this->safe_integer($fetchedOrder, 'canceledAt');
            }
            $timestampInMilliseconds = $this->parse_to_int($timestampInNanoseconds / 1000000);
            $symbol = $this->safe_string($market, 'symbol');
            $orderSideRaw = $this->safe_integer($fetchedOrder, 'side');
            $orderSide = null;
            if ($orderSideRaw === 0) {
                $orderSide = 'buy';
            } else {
                $orderSide = 'sell';
            }
            $currency = null;
            if ($orderSide === 'buy') {
                $currency = $this->safe_string($market, 'base');
            } else {
                $currency = $this->safe_string($market, 'quote');
            }
            $orderTypeRaw = $this->safe_integer($fetchedOrder, 'orderType');
            $orderType = null;
            if ($orderTypeRaw === 0) {
                $orderType = 'limit';
            } elseif ($orderTypeRaw === 1) {
                $orderType = 'market';
            } elseif ($orderTypeRaw === 2) {
                $orderType = 'MARKET_WITH_PROTECTION';
            }
            $timeInForce = null;
            $timeInForceRaw = $this->safe_integer($fetchedOrder, 'timeInForce');
            if ($timeInForceRaw === 0) {
                $timeInForce = 'IOC';
            } elseif ($timeInForceRaw === 1) {
                $timeInForce = 'GTC';
            } elseif ($timeInForceRaw === 2) {
                $timeInForce = 'FOK';
            }
            $priceTickSize = $this->safe_number($this->safe_dict($market, 'info'), 'priceTickSize');
            $rawPrice = $this->safe_integer($fetchedOrder, 'price');
            $price = null;
            if ($rawPrice === null || $orderType === 'market') {
                $price = 0;
            } else {
                $price = $rawPrice / (1 / $priceTickSize);
            }
            $amount = null;
            $amount = $this->safe_integer($fetchedOrder, 'quantity');
            if ($amount === null) {
                $amount = $this->safe_integer($fetchedOrder, 'qty');
            }
            if ($amount === null) {
                $amount = $this->safe_integer($fetchedOrder, 'orderQuantity');
            }
            $remainingAmount = null;
            $remainingAmount = $this->safe_integer($fetchedOrder, 'remainingQuantity');
            if ($remainingAmount === null && ($orderStatus === 'canceled' || $orderStatus === 'filled')) {
                $remainingAmount = $amount;
            }
            if ($remainingAmount === null) {
                $remainingAmount = 0;
            }
            $filledAmount = $amount - $remainingAmount;
            $tradeFeeRatios = $this->safe_dict($this->fees, 'trading');
            $rate = null;
            if ($orderSide === 'buy') {
                $rate = $this->safe_number($tradeFeeRatios, 'maker');
            } elseif ($orderSide === 'sell') {
                $rate = $this->safe_number($tradeFeeRatios, 'taker');
            }
            $quantityTickSize = $this->safe_number($this->safe_dict($market, 'info'), 'quantityTickSize');
            $decimalAmount = $amount / (1 / $quantityTickSize);
            $decimalFilledAmount = $filledAmount / (1 / $quantityTickSize);
            $decimalRemainingAmount = $remainingAmount / (1 / $quantityTickSize);
            $cost = $decimalFilledAmount * $price;
            $feeCost = $decimalAmount * $rate;
            return $this->safe_order(array(
                'id' => $exchangeOrderId,
                'clientOrderId' => $clientOrderId,
                'datetime' => $this->iso8601($timestampInMilliseconds),
                'timestamp' => $timestampInMilliseconds,
                'lastTradeTimestamp' => $timestampInMilliseconds,
                'status' => $orderStatus,
                'symbol' => $symbol,
                'type' => $orderType,
                'timeInForce' => $timeInForce,
                'side' => $orderSide,
                'price' => $price,
                'average' => null,
                'amount' => $decimalAmount,
                'filled' => $decimalFilledAmount,
                'remaining' => $decimalRemainingAmount,
                'cost' => $cost,
                'trades' => array(),
                'fee' => array(
                    'currency' => $currency, // a deduction from the asset hasattr($this, received) trade
                    'cost' => $feeCost,
                    'rate' => $rate,
                ),
                'info' => array(
                    'fetchedOrder' => $fetchedOrder,
                ),
            ));
        } else {
            return $this->safe_order(array());
        }
    }

    public function fetch_open_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        /**
         * fetch all unfilled currently open orders
         * @param {string} $symbol unified $market $symbol of the $market orders were made in
         * @param {int} [$since] the earliest time in ms to fetch orders for
         * @param {int} [$limit] the maximum number of order structures to retrieve
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {Order[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
         */
        $meta = $this->fetch_market_meta($symbol);
        $market = $this->safe_dict($meta, 'market');
        $request = array();
        $this->inject_sub_account_id($request, $params);
        $response = $this->restOsmiumPrivateGetOrders (array_merge($request, $params));
        $rawOrders = $this->safe_list($this->safe_dict($response, 'result'), 'orders');
        return $this->parse_orders($rawOrders, $market, $since, $limit);
    }

    public function fetch_raw_orders() {
        /**
         * fetch all orders from all markets
         * @param {string} symbol unified market symbol of the market orders were made in
         * @param {int} [since] the earliest time in ms to fetch orders for
         * @param {int} [limit] the maximum number of order structures to retrieve
         * @param {array} [params] extra parameters specific to the exchange API endpoint
         * @return {Order[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
         */
        $request = array();
        $this->inject_sub_account_id($request, array());
        $response = $this->restIridiumPrivateGetUsersSubaccountSubaccountIdOrders (array_merge($request));
        $rawOrders = $this->safe_list($this->safe_dict($response, 'result'), 'orders');
        return $rawOrders;
    }

    public function fetch_trades(string $symbol, ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * get the list of most recent trades for a particular $symbol
         * @see https://cubexch.gitbook.io/cube-api/rest-mendelev-api#book-market_id-recent-trades
         * @see https://cubexch.gitbook.io/cube-api/rest-mendelev-api#parsed-book-market_symbol-recent-trades
         * @param {string} $symbol unified $symbol of the $market to fetch trades for
         * @param {int} [$since] timestamp in ms of the earliest trade to fetch
         * @param {int} [$limit] the maximum number of trades to fetch
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {int} $params->lastId order id
         * @return {Trade[]} a list of ~@link https://docs.ccxt.com/#/?id=public-trades trade structures~
         */
        $meta = $this->fetch_market_meta($symbol);
        $symbol = $this->safe_string($meta, 'symbol');
        $market = $this->safe_dict($meta, 'market');
        $rawMarketId = $this->safe_string($this->safe_dict($market, 'info'), 'marketId');
        $rawMarketSymbol = $this->safe_string($this->safe_dict($market, 'info'), 'symbol');
        $request = null;
        $request = array(
            'market_id' => $rawMarketId,
        );
        $recentTradesResponse = $this->restMendelevPublicGetBookMarketIdRecentTrades (array_merge($request, $params));
        //
        // {
        //     "result":{
        //         "trades":array(
        //             array(
        //                 "tradeId":1192726,
        //                 "price":25730,
        //                 "aggressingSide":1,
        //                 "restingExchangeOrderId":775000423,
        //                 "fillQuantity":2048,
        //                 "transactTime":1710261845127064300,
        //                 "aggressingExchangeOrderId":775000298
        //             ),
        //             {
        //                 "tradeId":1192723,
        //                 "price":25730,
        //                 "aggressingSide":0,
        //                 "restingExchangeOrderId":775000298,
        //                 "fillQuantity":5000,
        //                 "transactTime":1710261844303742500,
        //                 "aggressingExchangeOrderId":774996895
        //             }
        //         )
        //     }
        // }
        //
        $request = array(
            'market_symbol' => $rawMarketSymbol,
        );
        $parsedRecentTradesResponse = $this->restMendelevPublicGetParsedBookMarketSymbolRecentTrades (array_merge($request, $params));
        //
        // {
        //     "result":{
        //         "ticker_id":"BTCUSDC",
        //         "trades":array(
        //             array(
        //                 "id":1106939,
        //                 "p":63565.6,
        //                 "q":0.01,
        //                 "side":"Ask",
        //                 "ts":1711153560907
        //             ),
        //             {
        //                 "id":1107084,
        //                 "p":63852.9,
        //                 "q":0.01,
        //                 "side":"Bid",
        //                 "ts":1711156552440
        //             }
        //         )
        //     }
        // }
        //
        $rawTrades => anyarray() = array( {
            'trades' => $this->safe_list($this->safe_dict($recentTradesResponse, 'result'), 'trades'),
            'parsedTrades' => $this->safe_list($this->safe_dict($parsedRecentTradesResponse, 'result'), 'trades'),
        } );
        return $this->parse_trades($rawTrades, $market);
    }

    public function parse_trades(array $trades, ?array $market = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        $parsedTrades = $this->safe_value($trades[0], 'parsedTrades');
        $finalTrades = array();
        if ($parsedTrades !== null && $this->count_items($parsedTrades) > 0) {
            for ($i = 0; $i < $this->count_items($parsedTrades); $i++) {
                $trade = $parsedTrades[$i];
                $finalTrades[] = $this->parse_trade($trade, $market);
            }
        }
        return $finalTrades;
    }

    public function parse_trade($trade, $market = null) {
        $timestampSeconds = 0;
        if ($trade['ts'] !== null) {
            $timestampSeconds = $this->safe_integer($trade, 'ts');
        } elseif ($trade['transactTime'] !== null) {
            $timestampNanoseconds = $trade['transactTime'];
            $timestampSeconds = $timestampNanoseconds / 1000000;
        }
        $datetime = $this->iso8601($timestampSeconds);
        $tradeSide = $this->safe_string($trade, 'side');
        $side = '';
        if ($tradeSide === 'Bid') {
            $side = 'buy';
        } elseif ($tradeSide === 'Ask') {
            $side = 'sell';
        }
        $marketSymbol = $this->safe_string($market, 'symbol');
        $price = floatval($this->safe_string($trade, 'p'));
        $amount = floatval($this->safe_string($trade, 'q'));
        return $this->safe_trade(array(
            'info' => $trade,
            'timestamp' => $timestampSeconds,
            'datetime' => $datetime,
            'symbol' => $marketSymbol,
            'id' => $this->safe_string($trade, 'id'),
            'order' => null,
            'type' => null,
            'takerOrMaker' => null,
            'side' => $side,
            'price' => $price,
            'amount' => $amount,
            'cost' => null,
            'fee' => null,
            'fees' => array(
                array(
                    'cost' => null,
                    'currency' => null,
                    'rate' => null,
                ),
            ),
        ), $market);
    }

    public function fetch_trading_fee(string $symbol, $params = array ()): array {
        /**
         * fetch the trading fees for a $market
         * @see https://cubexch.gitbook.io/cube-api/rest-iridium-api#users-fee-estimate-$market-id
         * @param {string} $symbol unified $market $symbol
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} a ~@link https://docs.ccxt.com/#/?id=fee-structure fee structure~
         */
        $meta = $this->fetch_market_meta($symbol);
        $symbol = $this->safe_string($meta, 'symbol');
        $market = $this->safe_dict($meta, 'market');
        $rawMarketId = $this->safe_integer($this->safe_dict($market, 'info'), 'marketId');
        $request = array(
            'market_id' => $rawMarketId,
        );
        $response = $this->restIridiumPrivateGetUsersFeeEstimateMarketId (array_merge($request, $params));
        // {
        //     "result" => {
        //         "userKey" => "123e4567-e89b-12d3-a456-426614174000",
        //         "makerFeeRatio" => 0,
        //         "takerFeeRatio" => 0
        //     }
        // }
        return array(
            'info' => $response,
            'symbol' => $symbol,
            'maker' => $this->safe_number($this->safe_dict($response, 'result'), 'makerFeeRatio'),
            'taker' => $this->safe_number($this->safe_dict($response, 'result'), 'takerFeeRatio'),
            'percentage' => null,
            'tierBased' => null,
        );
    }

    public function fetch_my_trades(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        $allOrders = $this->fetch_orders($symbol, $since, $limit, $params);
        $myTrades = array();
        for ($i = 0; $i < $this->count_items($allOrders); $i++) {
            $orderStatus = $this->safe_string($allOrders[$i], 'status');
            if ($orderStatus === 'filled') {
                $orderFills = $this->safe_dict($this->safe_dict($this->safe_dict($allOrders[$i], 'info'), 'fetchedOrder'), 'fills');
                $fillsLength = $this->count_items($orderFills);
                for ($j = 0; $j < $fillsLength; $j++) {
                    $trade = $orderFills[$j];
                    $parsedTrade = $this->parse_my_trade($trade, $allOrders[$i]);
                    $myTrades[] = $parsedTrade;
                }
            }
        }
        return $myTrades;
    }

    public function parse_my_trade(mixed $trade, mixed $order) {
        $tradeId = $this->safe_string($trade, 'tradeId');
        $timestampInNanoseconds = $this->safe_integer($trade, 'filledAt');
        $timestampInMilliseconds = $this->parse_to_int($timestampInNanoseconds / 1000000);
        $datetime = $this->iso8601($timestampInMilliseconds);
        $marketSymbol = $this->safe_string($order, 'symbol');
        $orderType = $this->safe_string($order, 'type');
        $orderId = null;
        if ($orderType === 'limit') {
            $orderId = $this->safe_string($order, 'id');
        } elseif ($orderType === 'market') {
            $orderId = $this->safe_string($order, 'clientOrderId');
        }
        $orderSide = $this->safe_string($order, 'side');
        $timeInForce = $this->safe_string($order, 'timeInForce');
        $takerOrMaker = null;
        if ($orderType === 'market' || $timeInForce === 'IOC' || $timeInForce === 'FOK') {
            $takerOrMaker = 'taker';
        } else {
            $takerOrMaker = 'maker';
        }
        $orderPrice = $this->safe_number($order, 'price');
        $orderAmount = $this->safe_number($order, 'amount');
        $cost = null;
        if ($orderPrice !== null) {
            $cost = $orderPrice * $orderAmount;
        }
        $fee = $this->safe_dict($order, 'fee');
        $fees = $this->safe_list($order, 'fees');
        return array(
            'id' => $tradeId,
            'timestamp' => $timestampInMilliseconds,
            'datetime' => $datetime,
            'symbol' => $marketSymbol,
            'order' => $orderId,
            'type' => $orderType,
            'side' => $orderSide,
            'takerOrMaker' => $takerOrMaker,
            'price' => $orderPrice,
            'amount' => $orderAmount,
            'cost' => $cost,
            'fee' => $fee,
            'fees' => $fees,
            'info' => $order,
        );
    }

    public function fetch_closed_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        $allOrders = $this->fetch_orders($symbol, $since, $limit, $params);
        $closedOrders = array();
        for ($i = 0; $i < $this->count_items($allOrders); $i++) {
            $orderStatus = $this->safe_string($allOrders[$i], 'status');
            if ($orderStatus === 'canceled' || $orderStatus === 'closed') {
                $closedOrders[] = $allOrders[$i];
            }
        }
        return $closedOrders;
    }

    public function fetch_status($params = array ()): mixed {
        /**
         * the latest known information on the availability of the exchange API
         * @see https://binance-docs.github.io/apidocs/spot/en/#system-status-system
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} a ~@link https://docs.ccxt.com/#/?id=exchange-status-structure status structure~
         */
        $response = $this->restIridiumPublicGetMarkets ($params);
        $keys = is_array($response) ? array_keys($response) : array();
        $keysLength = count($keys);
        $formattedStatus = null;
        if ($keysLength) {
            $formattedStatus = 'ok';
        } else {
            $formattedStatus = 'maintenance';
        }
        return array(
            'status' => $formattedStatus,
            'updated' => null,
            'eta' => null,
            'url' => null,
            'info' => null,
        );
    }

    public function fetch_deposits(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * fetch all $deposits made to an account
         * @param {string} code unified $currency code
         * @param {int} [$since] the earliest time in ms to fetch $deposits for
         * @param {int} [$limit] the maximum number of $deposits structures to retrieve
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=transaction-structure transaction structures~
         */
        $this->fetch_market_meta();
        $request = array();
        $currency = null;
        if ($symbol !== null) {
            $currency = $this->currency($symbol);
            $request['asset_symbol'] = $currency['assetId'];
        }
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $response = $this->restIridiumPrivateGetUsersSubaccountSubaccountIdDeposits (array_merge($request, $params));
        //
        // result => array(
        //     "161" => array(
        //       name => "primary",
        //       inner => array(
        //         array(
        //           assetId => 80005,
        //           amount => "5000000000",
        //           txnHash => "5E8xrkpCdwsczNDqGcezQ6agxDoFjXN9YVQFE4ZDk7vcdmdQHbPRSw7z3F769kkg4F57Vh4HsAsaKeFt8Z7qHhjZ",
        //           txnIndex => 1,
        //           createdAt => "2024-03-27T23:51:14.933108Z",
        //           updatedAt => "2024-03-27T23:51:28.93706Z",
        //           txnState => "confirmed",
        //           kytStatus => "accept",
        //           address => "79xoQgxNgKbjDrwp3Gb6t1oc1NmcgZ3PQFE7i1XCrk5x",
        //           fiatToCrypto => false,
        //         ),
        //       ),
        //     ),
        //   ),
        //
        $deposits = $this->safe_list($response, 'inner', array());
        return array( $this->parse_transaction($deposits, $currency) );
    }

    public function withdraw(string $code, float $amount, string $address, $tag = null, $params = array ()): array {
        /**
         * make a withdrawal
         * @see https://cubexch.gitbook.io/cube-api/rest-iridium-api#users-withdraw
         * @param {string} $code unified currency $code
         * @param {float} $amount the $amount to withdraw
         * @param {string} $address the $address to withdraw to
         * @param {string} $tag
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} a ~@link https://docs.ccxt.com/#/?id=transaction-structure transaction structure~
         */
        list($tag, $params) = $this->handle_withdraw_tag_and_params($tag, $params);
        $this->fetch_market_meta();
        $request = array(
            'amount' => (string) $amount,
            'destination' => $address,
            'assetId' => $code,
        );
        $this->inject_sub_account_id($request, $params);
        $response = $this->restIridiumPrivatePostUsersWithdraw (array_merge($request, $params));
        //
        // {
        //     "result" => {
        //       "status" => "pending",
        //       "approved" => false,
        //       "reason" => "text"
        //     }
        //     "result" => {
        //     "status" => "accept",
        //     "approved" => true
        //    }
        // }
        //
        return $response;
    }

    public function fetch_withdrawals(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * fetch all withdrawals made from an account
         * @param {string} code unified $currency code
         * @param {int} [$since] the earliest time in ms to fetch withdrawals for
         * @param {int} [$limit] the maximum number of withdrawals structures to retrieve
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=transaction-structure transaction structures~
         */
        $this->fetch_market_meta();
        $request = array();
        $currency = null;
        if ($symbol !== null) {
            $currency = $this->currency($symbol);
            $request['assetId'] = $currency['id'];
        }
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $response = $this->restIridiumPrivateGetUsersSubaccountSubaccountIdWithdrawals (array_merge($request, $params));
        //
        // $result => array(
        //     "161" => array(
        //       name => "primary",
        //       inner => array(
        //         array(
        //           assetId => 80005,
        //           amount => "100000000",
        //           createdAt => "2024-05-02T18:03:36.779453Z",
        //           updatedAt => "2024-05-02T18:03:37.941902Z",
        //           attemptId => 208,
        //           address => "6khUqefutr3xA6fEUnZfRMRGwER8BBTZZFFgBPhuUyyp",
        //           kytStatus => "accept",
        //           approved => true,
        //         ),
        //       ),
        //     ),
        //   ),
        //
        $result = $this->safe_value($response, 'result', array());
        return array( $this->parse_transaction($result, $currency) );
    }

    public function parse_transaction(mixed $transaction, ?array $currency = null): array {
        //
        // fetchDeposits
        //
        // result => array(
        //     "161" => array(
        //       name => "primary",
        //       inner => array(
        //         array(
        //           assetId => 80005,
        //           $amount => "5000000000",
        //           txnHash => "5E8xrkpCdwsczNDqGcezQ6agxDoFjXN9YVQFE4ZDk7vcdmdQHbPRSw7z3F769kkg4F57Vh4HsAsaKeFt8Z7qHhjZ",
        //           txnIndex => 1,
        //           createdAt => "2024-03-27T23:51:14.933108Z",
        //           updatedAt => "2024-03-27T23:51:28.93706Z",
        //           txnState => "confirmed",
        //           kytStatus => "accept",
        //           $address => "79xoQgxNgKbjDrwp3Gb6t1oc1NmcgZ3PQFE7i1XCrk5x",
        //           fiatToCrypto => false,
        //         ),
        //       ),
        //     ),
        //   ),
        //
        // fetchWithdrawals
        //
        // result => array(
        //     "161" => array(
        //       name => "primary",
        //       inner => array(
        //         array(
        //           assetId => 80005,
        //           $amount => "100000000",
        //           createdAt => "2024-05-02T18:03:36.779453Z",
        //           updatedAt => "2024-05-02T18:03:37.941902Z",
        //           attemptId => 208,
        //           $address => "6khUqefutr3xA6fEUnZfRMRGwER8BBTZZFFgBPhuUyyp",
        //           kytStatus => "accept",
        //           approved => true,
        //         ),
        //       ),
        //     ),
        //   ),
        //
        $currencyId = $this->safe_string($transaction, 'assetId');
        $code = $this->safe_currency_code($currencyId);
        $amount = $this->safe_number($transaction, 'amount');
        $timestamp = $this->parse8601($this->safe_string($transaction, 'createdAt'));
        $updated = $this->parse8601($this->safe_string($transaction, 'updatedAt'));
        $status = $this->parse_transaction_status($this->safe_string($transaction, 'kytStatus'));
        $address = $this->safe_string($transaction, 'address');
        return array(
            'info' => $transaction,
            'id' => null,
            'txid' => null,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'network' => null,
            'addressFrom' => null,
            'address' => null,
            'addressTo' => $address,
            'tagFrom' => null,
            'tag' => null,
            'tagTo' => null,
            'type' => null,
            'amount' => $amount,
            'currency' => $code,
            'status' => $status,
            'updated' => $updated,
            'fee' => null,
            'comment' => null,
            'internal' => null,
        );
    }

    public function parse_transaction_status(mixed $status) {
        $statuses = array(
            // what are other $statuses here?
            'WITHHOLD' => 'ok',
            'UNCONFIRMED' => 'pending',
            'CONFIRMED' => 'ok',
            'COMPLETED' => 'ok',
            'PENDING' => 'pending',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function count_with_loop($items) {
        $count = 0;
        for ($i = 0; $i < $count($items); $i++) {
            $count += 1;
        }
        return $count;
    }

    public function count_items($input) {
        $count = 0;
        if (gettype($input) === 'array' && array_keys($input) === array_keys(array_keys($input))) {
            $count = $this->count_with_loop($input);
        } elseif (gettype($input) === 'array' && $input !== null) {
            $keys = is_array($input) ? array_keys($input) : array();
            $count = $this->count_with_loop($keys);
        }
        return $count;
    }

    public function count_decimal_places(mixed $number) {
        $numberString = (string) $number;
        if (mb_strpos($numberString, '.') === -1) {
            return 0;
        }
        $parts = explode('.', $numberString);
        return count($parts[1]);
    }
}
